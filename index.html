<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gates-like Slot — Demo (clean)</title>
  <style>
    :root{--cell:160px;--gap:12px}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial;background:linear-gradient(#0b0c10,#050507);color:#eee;display:flex;justify-content:center;padding:28px}
    .app{max-width:1100px;width:100%}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    .arena{display:grid;grid-template-columns:1fr;gap:12px}
    .sidebar{background:#0f1013;padding:12px;border-radius:10px}
    .main{background:#0b0c10;padding:18px;border-radius:12px}
    .slot{display:grid;grid-template-columns:repeat(5,var(--cell));grid-auto-rows:var(--cell);gap:var(--gap);justify-content:center}
    .cell{width:var(--cell);height:var(--cell);background:#0a0b0f;border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center;position:relative}
    .cell img{width:100%;height:100%;object-fit:contain;display:block;background:#070708;transform:translateY(0);transition:transform 900ms cubic-bezier(.2,.9,.2,1),opacity 900ms}
    .cell.win{outline:3px solid rgba(255,200,40,0.9);box-shadow:0 6px 18px rgba(255,180,20,0.18);transform:scale(1.03);z-index:2}
    .floatWin{position:absolute;left:50%;top:18%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#ffd966;padding:8px 14px;border-radius:8px;font-weight:700;font-size:18px;pointer-events:none}
    .bigWin{position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);background:linear-gradient(45deg,#ffd966,#ffb347);color:#2b1f00;padding:22px 36px;border-radius:12px;font-size:34px;font-weight:800;box-shadow:0 20px 60px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center}
    /* .multBadge removed (multipliers disabled) */
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    button{background:#6c63ff;border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer}
    .stats{font-size:13px;margin-top:8px}
    .low{opacity:.25}
    .payline{outline:3px solid transparent}
    .cell.spinning img{filter: blur(3px) saturate(1.05); transform: scale(1.02);} 
    /* win pulse */
    @keyframes win-pulse { 0% { box-shadow: 0 6px 18px rgba(255,180,20,0.18); transform: scale(1.02);} 50% { box-shadow: 0 12px 30px rgba(255,210,60,0.28); transform: scale(1.06);} 100% { box-shadow: 0 6px 18px rgba(255,180,20,0.18); transform: scale(1.02);} }
    .cell.win{outline:3px solid rgba(255,200,40,0.95); animation: win-pulse 900ms ease-in-out 0s 2;}
    /* coin particle */
    .coin-particle{position:fixed;width:18px;height:18px;border-radius:50%;background:radial-gradient(circle at 30% 35%, #fff6, #ffd54a);box-shadow:0 6px 14px rgba(0,0,0,0.4);pointer-events:none;transform-origin:center center;}
    @keyframes floatUp { from { transform: translateY(0) scale(1); opacity:1 } to { transform: translateY(-72px) scale(1.2); opacity:0 } }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Gates-like Slot — Demo (Reels 5×3)</h1>
      <div id="balance">Credits: 1000.00</div>
    </header>
    <div class="arena">
      <main class="main" style="grid-column:1 / -1">
        <div style="display:flex;justify-content:center;">
          <div style="width:calc(var(--cell)*5 + var(--gap)*4);max-width:100%;background:#0b0c10;padding:10px;border-radius:12px;">
            <div style="position:relative;">
              <div class="slot" id="slot"></div>
              <svg id="payline-overlay" style="position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible"></svg>
            </div>
          </div>
        </div>
        <div class="controls">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="betMinus">-</button>
            <div>Bet: <span id="betDisplay">1.00</span></div>
            <button id="betPlus">+</button>
          </div>
          <button id="spin">SPIN</button>
          <button id="autoSpin">Auto Spin</button>
          <div style="display:flex;gap:8px;align-items:center">
            <label style="font-size:12px;margin-right:6px">Spin Speed</label>
            <input id="spinSpeed" type="range" min="50" max="200" value="100" />
          </div>
          <div id="mode">Mode: Base</div>
          <div id="fs">Free Spins: 0</div>
          <div id="lastWin">Last Win: 0</div>
        </div>
      </main>
    </div>
  </div>
  <script>
    // Audio removed: replace with no-op stubs
    // Audio removed: keep harmless no-op stubs for future reactivation
    function playBeep(){ }
    function playClick(){ }
    function playStopTone(){ }
    function playCoinSound(){ }
    function playLeverSound(){ }
              <button id="autoSpin">Auto Spin</button>
              <div style="display:flex;align-items:center;gap:6px">
                <label style="font-size:13px">Auto Count</label>
                <input id="autoCount" type="number" min="0" step="1" placeholder="0 = infinite" style="width:80px;padding:6px;border-radius:6px;border:1px solid #222;background:#0b0c10;color:#eee" />
              </div>
    // pickWeighted considers ante boosting scatter
    let anteOn = false; const ANTE_MULT = 25; const ANTE_SCATTER_BOOST = 3;
    // Image prefix and symbol definitions (was missing — causes symbols to not load)
    const IMG_PREFIX = 'img/';
    const ROWS = 3, COLS = 5, TOTAL = ROWS * COLS;
    const SYMBOLS = [];
    for (let i = 1; i <= 13; i++) SYMBOLS.push({ name: 'S' + i, img: `${IMG_PREFIX}user${i}.png` });
    const SCATTER = { name: 'ZEUS', isScatter: true, img: `${IMG_PREFIX}scatter.png` };
    const WEIGHTED = [];
    for (let i = 0; i < SYMBOLS.length; i++) WEIGHTED.push({ sym: SYMBOLS[i], weight: 12 - i });
    WEIGHTED.push({ sym: SCATTER, weight: 2 });

    const PAYTABLE = {
      S1: {12:100,10:50,8:20},
      S2: {12:50,10:20,8:5},
      S3: {12:30,10:10,8:4},
      S4: {12:24,10:4,8:3},
      S5: {12:20,10:3,8:2},
      S6: {12:16,10:2.4,8:1.6},
      S7: {12:10,10:2,8:1},
      S8: {12:8,10:1.8,8:0.8},
      S9: {12:4,10:1.5,8:0.5},
      S10:{12:4,10:1.5,8:0.5},
      S11:{12:4,10:1.5,8:0.5},
      S12:{12:4,10:1.5,8:0.5}
    };
    const SCATTER_PAYOUT = {6:200,5:100,4:6};

    // Bind commonly-used DOM elements
    const slot = document.getElementById('slot');
    const balanceEl = document.getElementById('balance');
    const modeEl = document.getElementById('mode');
    const fsEl = document.getElementById('fs');
    const lastWinEl = document.getElementById('lastWin');
    const leftInfo = document.getElementById('leftInfo');
    // --- Secure PRNG (xoshiro128++) with seedable state
    (function(){
      let s = new Uint32Array(4);
      function rotl(x,k){ return ((x<<k) | (x>>> (32-k))) >>> 0; }
      function next(){
        const result = (rotl((s[0] + s[3])>>>0, 7) + s[0]) >>> 0;
        const t = (s[1] << 9) >>> 0;
        s[2] ^= s[0]; s[3] ^= s[1]; s[1] ^= s[2]; s[0] ^= s[3];
        s[2] ^= t; s[3] = rotl(s[3], 11);
        return result / 0x100000000; // [0,1)
      }
      function seedFromBytes(bytes){
        const dv = new DataView(new ArrayBuffer(16));
        for(let i=0;i<4;i++) dv.setUint32(i*4, (bytes[i*4]||0) | ((bytes[i*4+1]||0)<<8) | ((bytes[i*4+2]||0)<<16) | ((bytes[i*4+3]||0)<<24), true);
        s = new Uint32Array(dv.buffer);
      }
      function seedFromHex(hex){
        // accept 8..32 hex chars, pad/truncate to 32 chars (16 bytes)
        const h = hex.replace(/[^0-9a-fA-F]/g,'');
        const padded = (h + '0'.repeat(32)).slice(0,32);
        const bytes = new Uint8Array(16);
        for(let i=0;i<16;i++) bytes[i] = parseInt(padded.substr(i*2,2),16) || 0;
        seedFromBytes(bytes);
      }
      function seedToHex(){
        const dv = new DataView(s.buffer.slice(0));
        let out = '';
        for(let i=0;i<4;i++){ out += dv.getUint32(i*4, true).toString(16).padStart(8,'0'); }
        return out.slice(0,32);
      }
      function seedFromCrypto(){ const arr = new Uint32Array(4); window.crypto.getRandomValues(arr); s = arr; }
      // expose rng and seeding
      window._rng = next; window._seedFromBytes = seedFromBytes; window._seedFromCrypto = seedFromCrypto; window._seedFromHex = seedFromHex; window._seedToHex = seedToHex;
      // Background advancer
      let advanceInterval = null;
      function startAdvance(){ if(advanceInterval) return; advanceInterval = setInterval(()=>{ for(let i=0;i<8;i++) next(); }, 64); }
      function stopAdvance(){ if(advanceInterval){ clearInterval(advanceInterval); advanceInterval = null; } }
      startAdvance(); window.startRng = startAdvance; window.stopRng = stopAdvance;
    })();
    function rng(){ return (window._rng && window._rng()) || Math.random(); }

    // Local-only PRNG: no external beacon used
    function pickWeighted(){
      const effective = WEIGHTED.map(e => ({ sym: e.sym, weight: e.weight }));
      if(anteOn){
        for(const e of effective){ if(e.sym && e.sym.isScatter) e.weight *= ANTE_SCATTER_BOOST; }
      }
      const total = effective.reduce((s,i)=>s+i.weight,0);
      let r=rng()*total;
      for(const e of effective){
        if(r < e.weight){
          const s = Object.assign({}, e.sym);
          return s;
        }
        r -= e.weight;
      }
      const fallback = Object.assign({}, effective[0].sym);
      return fallback;
    }

    // --- Reels / Payline support
    // deterministic per-reel strips generated once from the PRNG seed
    let reelStrips = null; const REEL_STRIP_LEN = 64;
    function initReelStrips(){
      reelStrips = [];
      for(let r=0;r<COLS;r++){
        const strip = [];
        for(let i=0;i<REEL_STRIP_LEN;i++){ const w = WEIGHTED[Math.floor(rng()*WEIGHTED.length)]; strip.push(w.sym); }
        reelStrips.push(strip);
      }
    }

    // Preload images to avoid visual jumps during animation
    const _imgCache = new Map();
    function preloadImages(){
      const urls = [];
      for(let i=1;i<=13;i++) urls.push(`${IMG_PREFIX}user${i}.png`);
      urls.push(`${IMG_PREFIX}scatter.png`);
      urls.forEach(u=>{ const im=new Image(); im.src=u; _imgCache.set(u,im); });
    }
    
    function buildReelsFinal(){
      if(!reelStrips) initReelStrips();
      const final = Array(ROWS*COLS).fill(null);
      const starts = [];
      for(let c=0;c<COLS;c++){
        const strip = reelStrips[c];
        const start = Math.floor(rng()*strip.length);
        starts.push(start);
        for(let r=0;r<ROWS;r++) final[r*COLS + c] = strip[(start + r) % strip.length];
      }
      return {final, starts};
    }

    // paylines: classic 10-line for 5x3 (indices computed per current ROWS/COLS)
    function getPaylines(rows, cols){
      // positions are (r,c) -> idx = r*cols + c
      if(rows!==3 || cols!==5) return [];
      const lines = [
        [ [0,0],[0,1],[0,2],[0,3],[0,4] ],
        [ [1,0],[1,1],[1,2],[1,3],[1,4] ],
        [ [2,0],[2,1],[2,2],[2,3],[2,4] ],
        [ [0,0],[1,1],[2,2],[1,3],[0,4] ],
        [ [2,0],[1,1],[0,2],[1,3],[2,4] ],
        [ [0,0],[0,1],[1,2],[0,3],[0,4] ],
        [ [2,0],[2,1],[1,2],[2,3],[2,4] ],
        [ [1,0],[2,1],[2,2],[2,3],[1,4] ],
        [ [1,0],[0,1],[0,2],[0,3],[1,4] ],
        [ [0,0],[1,1],[1,2],[1,3],[0,4] ]
      ];
      return lines.map(line => line.map(([r,c])=> r*cols + c));
    }

    function evaluateReels(grid){
      const paylines = getPaylines(ROWS,COLS);
      let total=0; let scatterCount=0; const wins=[];
      // count scatters
      grid.forEach(s=>{ if(s && s.isScatter) scatterCount++; });
      const scatterWin = payoutForScatter(scatterCount);
      total += scatterWin;
      // evaluate each payline left-to-right (match consecutive identical symbols from reel0)
      for(const pl of paylines){
        const first = grid[pl[0]]; if(!first || first.isScatter) continue;
        let count=1;
        for(let i=1;i<pl.length;i++){ const sym = grid[pl[i]]; if(sym && !sym.isScatter && sym.name===first.name) count++; else break; }
        if(count>=3){ const p = payoutForCount(first.name, count); if(p>0){ total += p; wins.push({line:pl, symbol:first.name, count, payout:p, indices: pl.slice(0,count)}); } }
      }
      return {win: total, finalScatter: scatterCount, wins};
    }

    const PAYLINE_COLORS = ['#ffd966','#8be9fd','#ff9ff3','#a29bfe','#b8ffb0','#ffb86b','#ff6b6b','#9ae66e','#74c0fc','#f78fb3'];

    // build grid DOM (dynamic)
    function buildGrid(){
      slot.innerHTML='';
      for(let i=0;i<TOTAL;i++){
        const c=document.createElement('div'); c.className='cell';
        const im=document.createElement('img'); im.id=`img-${i}`;
        // default to a rotating set of symbol images until reels generate actual symbols
        const symIdx = (i % SYMBOLS.length);
        im.src = SYMBOLS[symIdx] ? SYMBOLS[symIdx].img : `${IMG_PREFIX}user1.png`;
        c.appendChild(im); slot.appendChild(c);
      }
    }
    buildGrid();
    preloadImages();

    // Reels-only: no mode switching
    // ensure Ante/Buy buttons are disabled for Reels
    document.addEventListener('DOMContentLoaded', ()=>{
      const buyBtn = document.getElementById('buyBonus'); const anteBtn = document.getElementById('toggleAnte');
      if(buyBtn) buyBtn.disabled = true; if(anteBtn) anteBtn.disabled = true;
    });

    // wire audio / spin-speed controls
    document.addEventListener('DOMContentLoaded', ()=>{
      const audioBtn = document.getElementById('toggleAudio');
      const spinSpeed = document.getElementById('spinSpeed');
      if(audioBtn){ audioBtn.disabled = true; audioBtn.textContent = 'Audio Removed'; }
      if(spinSpeed){ spinSpeed.addEventListener('input', (e)=>{
        const v = Number(e.target.value)/100; // scale factor
        TIMINGS.baseDuration = Math.round(680 / v);
        TIMINGS.perReelDelay = Math.round(180 / v);
        TIMINGS.perReelExtra = Math.round(140 / v);
        TIMINGS.cycleInterval = Math.round(120 / v);
        TIMINGS.fastSwipe = Math.round(240 / v);
        TIMINGS.settle = Math.round(300 / v);
        showFloat(`Speed ${(v*100).toFixed(0)}%`, 600);
      }); }
    });

    // payout helpers
    function payoutForCount(name, count){
      const table = PAYTABLE[name];
      if(!table) return 0;
      const keys = Object.keys(table).map(Number).sort((a,b)=>a-b);
      let matched = 0; for(const k of keys) if(count>=k) matched=k;
      return matched? table[matched] : 0;
    }

    function payoutForScatter(count){
      if(count>=6) return SCATTER_PAYOUT[6]||0;
      if(count>=5) return SCATTER_PAYOUT[5]||0;
      if(count>=4) return SCATTER_PAYOUT[4]||0;
      return 0;
    }

    // animate tumble: set image src and translateY from -drop*cell -> 0
    function animateTumble(finalGrid, drop, newFlag){
      const imgs=document.querySelectorAll('.cell img');
      const unit = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||96;
      imgs.forEach((img,i)=>{ img.style.transition='none'; img.src = finalGrid[i].img; img.style.transform = `translateY(${-drop[i]*unit}px)`; img.style.opacity = newFlag[i]?'0':'1';
        const cell = finalGrid[i]; img.title = '';
      });
      // force reflow
      slot.getBoundingClientRect();
      imgs.forEach((img,i)=>{ const col = i % COLS; const delay = col*60; img.style.transition = `transform 900ms cubic-bezier(.2,.9,.2,1) ${delay}ms, opacity 900ms ${delay}ms`; img.style.transform='translateY(0)'; img.style.opacity='1'; });
      return new Promise(r=>setTimeout(r,1250));
    }

    // Reel spin animation: spins each column from offset to final visible symbols
    // Timing configuration for reel spins (easy to tweak)
    const TIMINGS = {
      cycles: 5,               // slightly more cycles for a weighty feel
      baseDuration: 820,       // larger base duration for more dramatic decel (ms)
      perReelDelay: 220,       // increased stagger between reel starts (ms)
      perReelExtra: 160,       // extra duration per next reel (ms)
      cycleInterval: 140,      // spacing between visual cycles (ms)
      fastSwipe: 260,          // duration of each fast translate (ms)
      settle: 420,             // longer settle animation (ms)
      beepBaseFreq: 640,       // base beep frequency (shifted slightly lower)
      beepGain: 0.045          // lower beep volume
    };

    // runtime options
    let AUDIO_ON = false;
    let AUTO_SPIN_ON = false; let _autoSpinInterval = null; let AUTO_SPIN_DELAY = 700; // ms between spins
    let autoSpinCount = 0; // 0 = infinite

    async function animateReels(result){
      // Smooth reel animation using requestAnimationFrame + easing
      // result: { final: [...symbols], starts: [startIndices] }
      const imgs = document.querySelectorAll('.cell img');
      const unit = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||96;
      const { baseDuration, perReelDelay, perReelExtra, beepBaseFreq, beepGain } = TIMINGS;

      function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

      const perReelPromises = [];

      for(let c=0;c<COLS;c++){
        perReelPromises.push(new Promise((resolve)=>{
          const startDelay = perReelDelay * c;
          const totalDur = baseDuration + perReelExtra * c;
          const strip = reelStrips && reelStrips[c] ? reelStrips[c] : null;
          const startIndex = (result.starts && result.starts[c]) ? result.starts[c] : Math.floor(Math.random() * (strip?strip.length:12));

          // compute number of steps (symbol advances) to perform
          const steps = Math.max(24, Math.round(totalDur / 25) * 3);

          // animation variables
          let started = false; let rafId = null; let frameLastStep = -1;

          function startSpin(){
            const t0 = performance.now();
            started = true;
            function frame(now){
              const elapsed = now - t0;
              const u = Math.min(1, elapsed / totalDur);
              const e = easeOutCubic(u);
              const stepNow = Math.min(steps, Math.floor(e * steps));
              if(stepNow !== frameLastStep){
                // update visible imgs for this column based on stepNow
                const idxBase = (startIndex + stepNow) % (strip ? strip.length : 1);
                for(let r=0;r<ROWS;r++){
                  const imgIdx = r*COLS + c; const el = imgs[imgIdx];
                  if(!el) continue;
                  const sym = strip ? strip[(idxBase + r) % strip.length] : result.final[imgIdx];
                  el.src = (sym && sym.img) ? sym.img : `${IMG_PREFIX}user1.png`;
                }
                // audio click per step (slightly different pitch per reel)
                playClick(1400 - c*40, 0.025, 0.035);
                // add spinning class to column cells
                for(let r=0;r<ROWS;r++){ const cell = imgs[r*COLS + c].parentElement; if(cell) cell.classList.add('spinning'); }
                frameLastStep = stepNow;
              }
              if(u < 1){ rafId = requestAnimationFrame(frame); }
              else {
                // final: set final images for this column
                for(let r=0;r<ROWS;r++){ const imgIdx = r*COLS + c; const el = imgs[imgIdx]; if(!el) continue; const sym = result.final[imgIdx]; el.src = sym.img; el.style.transition = 'transform 260ms cubic-bezier(.2,.9,.2,1)'; el.style.transform = 'translateY(0)'; }
                // stop tone and remove spinning class
                playStopTone(beepBaseFreq + c*48, 0.12, 0.08);
                for(let r=0;r<ROWS;r++){ const cell = imgs[r*COLS + c].parentElement; if(cell) cell.classList.remove('spinning'); }
                resolve();
              }
            }
            rafId = requestAnimationFrame(frame);
          }

          // schedule start after column-specific delay
          setTimeout(()=>{ startSpin(); }, startDelay);
        }));
      }

      await Promise.all(perReelPromises);
      // small global settle
      await new Promise(r=>setTimeout(r,120));
      return;
    }

    function clearHighlights(){ document.querySelectorAll('.cell').forEach(c=> c.classList.remove('win','payline')); }

    // state
    let balance = 1000; let inFreeSpins=false; let freeSpins=0;
    // bet controls
    let betPerSpin = 1.0; const BET_STEP = 0.5; const MIN_BET = 0.1; const MAX_BET = 1000;

    function updateUI(){
      balanceEl.textContent = `Credits: ${balance.toFixed(2)}`;
      modeEl.textContent = `Mode: ${inFreeSpins?'Free Spins':'Base'}`;
      fsEl.textContent = `Free Spins: ${freeSpins}`;
      if(leftInfo) leftInfo.innerHTML = '';
      if(inFreeSpins){ /* no round multiplier to display */ }
      const betDisplayEl = document.getElementById('betDisplay'); if(betDisplayEl) betDisplayEl.textContent = betPerSpin.toFixed(2);
      const buyBonusEl = document.getElementById('buyBonus'); if(buyBonusEl) { buyBonusEl.textContent = `Buy Bonus (${(betPerSpin*100).toFixed(2)} credits)`; buyBonusEl.disabled = anteOn; }
      const toggleAnteEl = document.getElementById('toggleAnte'); if(toggleAnteEl) toggleAnteEl.textContent = `Ante x25 ${anteOn? 'ON' : 'OFF'}`;
      const autoBtn = document.getElementById('autoSpin'); if(autoBtn) autoBtn.textContent = AUTO_SPIN_ON ? 'Stop Auto' : 'Auto Spin';
      const autoCountEl = document.getElementById('autoCount'); if(autoCountEl){ if(autoSpinCount>0 && AUTO_SPIN_ON) autoCountEl.value = autoSpinCount; }
    }
    updateUI();

    // UI helpers for showing wins
    function showFloat(text, ttl=900){
      const el = document.createElement('div'); el.className='floatWin'; el.textContent = text; document.body.appendChild(el);
      setTimeout(()=>{ el.style.transition='opacity 600ms'; el.style.opacity='0'; setTimeout(()=>el.remove(),600); }, ttl);
    }
    function showBigWin(text, ttl=1600){
      const el = document.createElement('div'); el.className='bigWin'; el.textContent = text; document.body.appendChild(el);
      setTimeout(()=>{ el.style.transition='opacity 800ms'; el.style.opacity='0'; setTimeout(()=>el.remove(),800); }, ttl);
    }

    // Win sounds (small and big)
    function playSmallWinSound(){ }
    function playBigWinSound(){ }

    // coin particle effect
    function spawnCoinParticles(x,y,count=8){
      for(let i=0;i<count;i++){
        const p = document.createElement('div'); p.className='coin-particle'; document.body.appendChild(p);
        const angle = (Math.PI*2)*(i/count) + (Math.random()-0.5)*0.6; const speed = 40 + Math.random()*80;
        p.style.left = (x - 9) + 'px'; p.style.top = (y - 9) + 'px';
        p.style.opacity='1'; p.style.transform = 'translateY(0) scale(1)';
        const dx = Math.cos(angle)*speed; const dy = Math.sin(angle)*speed * -1;
        // animate using CSS keyframes
        p.animate([
          { transform: `translate(0px,0px) scale(1)`, opacity:1 },
          { transform: `translate(${dx}px,${dy}px) scale(1.15)`, opacity:0 }
        ], { duration: 700 + Math.random()*300, easing: 'cubic-bezier(.2,.8,.2,1)' });
        setTimeout(()=> p.remove(), 1200);
      }
    }

    // payline drawing: draws an animated glowing polyline over the grid
    function getCellCenter(idx){
      const imgs = document.querySelectorAll('.cell img'); const el = document.getElementById(`img-${idx}`);
      if(!el) return {x: window.innerWidth/2, y: window.innerHeight/2};
      const r = el.getBoundingClientRect(); return { x: r.left + r.width/2, y: r.top + r.height/2 };
    }
    function hexToRgba(hex, a=1){
      if(!hex) return `rgba(255,220,120,${a})`;
      const h = hex.replace('#',''); const bigint = parseInt(h.length===3? h.split('').map(c=>c+c).join('') : h,16);
      const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255; return `rgba(${r},${g},${b},${a})`;
    }
    function drawPayline(indices, color){
      const svg = document.getElementById('payline-overlay'); if(!svg) return new Promise(r=>r());
      // clear
      while(svg.firstChild) svg.removeChild(svg.firstChild);
      const svgRect = svg.getBoundingClientRect();
      const pts = indices.map(i=>{ const p = getCellCenter(i); return { x: p.x - svgRect.left, y: p.y - svgRect.top }; });
      if(pts.length < 2) return new Promise(r=>r());
      const pathData = pts.map((p,ix)=> `${ix===0?'M':'L'} ${p.x} ${p.y}`).join(' ');
      const glow = document.createElementNS('http://www.w3.org/2000/svg','path'); glow.setAttribute('d', pathData); glow.setAttribute('class','glow'); glow.setAttribute('stroke', hexToRgba(color,0.9)); svg.appendChild(glow);
      const line = document.createElementNS('http://www.w3.org/2000/svg','path'); line.setAttribute('d', pathData); line.setAttribute('class','line'); line.setAttribute('stroke', hexToRgba(color,1)); svg.appendChild(line);
      // animate stroke-dashoffset for a moving light
      const len = line.getTotalLength(); line.style.strokeDasharray = `${len}`; line.style.strokeDashoffset = `${len}`;
      line.animate([{ strokeDashoffset: len }, { strokeDashoffset: 0 }], { duration: 700, easing: 'cubic-bezier(.2,.9,.2,1)' });
      glow.style.opacity = '0.9'; glow.animate([{ opacity:0 },{ opacity:0.9 }], { duration: 350, fill:'forwards' });
      return new Promise((resolve)=>{ setTimeout(()=>{ if(svg) while(svg.firstChild) svg.removeChild(svg.firstChild); resolve(); }, 900); });
    }
    async function drawPaylines(wins){
      if(!wins || !wins.length) return;
      for(let i=0;i<wins.length;i++){
        const w = wins[i]; const color = PAYLINE_COLORS[i % PAYLINE_COLORS.length] || '#ffd966';
        try{ await drawPayline(w.indices, color); }catch(e){}
        // small gap between lines
        await new Promise(r=>setTimeout(r, 140));
      }
    }

    // evaluate tumble chains, handle multipliers and free spins
    async function evaluateSpin(grid, isFreeSpin=false){
      // For Reels-only mode, evaluation is handled by evaluateReels
      return evaluateReels(grid);
    }

    // spin workflow: deduct bet (or use free spin), animate and evaluate
    async function spin(){
      document.getElementById('spin').disabled=true;
      const baseCost = betPerSpin;
      const spinCost = anteOn ? baseCost * ANTE_MULT : baseCost;
      if(!inFreeSpins){
        if(balance < spinCost){ alert('Not enough credits for this spin'); document.getElementById('spin').disabled=false; return; }
        balance -= spinCost;
        // audio feedback: coin in hopper + lever pull
        playCoinSound();
        setTimeout(()=>{ playLeverSound(); }, 90);
      }
      updateUI();
      let res;
      // Reels-only flow
      const built = buildReelsFinal();
      await animateReels(built);
      res = await evaluateSpin(built.final, inFreeSpins);
      // highlight payline wins if any
      if(res.wins && res.wins.length){ clearHighlights(); res.wins.forEach((w,idx)=>{
        const color = PAYLINE_COLORS[idx % PAYLINE_COLORS.length];
        w.indices.forEach(i=>{ const el = document.getElementById(`img-${i}`); if(el){ el.parentElement.classList.add('payline'); el.parentElement.style.outlineColor = color; el.parentElement.style.boxShadow = `0 6px 18px ${color}40`; } });
      });
        // draw first payline for clarity
        try{ if(res.wins && res.wins.length) drawPaylines(res.wins); }catch(e){}
        // update left-info with textual payline wins
        if(leftInfo) leftInfo.innerHTML = res.wins.map((w,i)=> `Line ${i+1}: ${w.symbol} x${w.count} → ${w.payout}`).join('<br>');
      }
      await new Promise(r=>setTimeout(r,900));
      clearHighlights(); if(leftInfo) leftInfo.innerHTML = '';
      const win = res.win; const finalScatter = res.finalScatter;
      if(win>0){ balance += win; showFloat(`Win: ${win.toFixed(2)}`);
        // visual + audio feedback for wins
        // mark cells that were part of wins
        document.querySelectorAll('.cell').forEach(c=> c.classList.remove('win'));
        if(res.wins && res.wins.length){ res.wins.forEach(w=> w.indices.forEach(i=>{ const el=document.getElementById(`img-${i}`); if(el) el.parentElement.classList.add('win'); })); }
        // choose sound based on magnitude
        if(win >= betPerSpin * 10) {
          playBigWinSound();
          // spawn from first winning cell if available
          const firstIdx = (res.wins && res.wins[0] && res.wins[0].indices && res.wins[0].indices[0]) ? res.wins[0].indices[0] : null;
          const p = firstIdx !== null ? getCellCenter(firstIdx) : { x: window.innerWidth/2, y: window.innerHeight/2 };
          spawnCoinParticles(p.x, p.y, 18); showBigWin(`Big Win: ${win.toFixed(2)}`);
        } else {
          playSmallWinSound();
          const firstIdx = (res.wins && res.wins[0] && res.wins[0].indices && res.wins[0].indices[0]) ? res.wins[0].indices[0] : null;
          const p = firstIdx !== null ? getCellCenter(firstIdx) : { x: window.innerWidth/2, y: window.innerHeight/2 };
          spawnCoinParticles(p.x, p.y, 8);
        }
      }

      // scatter triggers
      if(!inFreeSpins && finalScatter >= 4){ inFreeSpins = true; freeSpins = Math.min(100, freeSpins + 15); }
      else if(inFreeSpins && finalScatter >= 3){ freeSpins = Math.min(100, freeSpins + 5); }

      // consume free spin
      if(inFreeSpins){ freeSpins = Math.max(0, freeSpins - 1); if(freeSpins === 0){ inFreeSpins = false; } }

      updateUI(); lastWinEl.textContent = `Last Win: ${win.toFixed(2)}`;
      document.getElementById('spin').disabled=false;
      // auto-stop if balance too low
      if(!inFreeSpins && AUTO_SPIN_ON && balance < betPerSpin){ AUTO_SPIN_ON=false; const autoBtn = document.getElementById('autoSpin'); if(autoBtn) autoBtn.textContent='Auto Spin'; if(_autoSpinInterval){ clearInterval(_autoSpinInterval); _autoSpinInterval=null; } }
    }

    // wire controls
    // Reels-only UI (no mode toggle)
    document.addEventListener('DOMContentLoaded', ()=>{
      const spinBtn = document.getElementById('spin'); if(spinBtn) spinBtn.addEventListener('click', spin);
      const autoBtn = document.getElementById('autoSpin'); const autoCountEl = document.getElementById('autoCount'); if(autoCountEl){ autoCountEl.addEventListener('input', (e)=>{ const v = Number(e.target.value)||0; autoSpinCount = Math.max(0, Math.floor(v)); }); }
      if(autoBtn){ autoBtn.addEventListener('click', ()=>{
        AUTO_SPIN_ON = !AUTO_SPIN_ON; autoBtn.textContent = AUTO_SPIN_ON ? 'Stop Auto' : 'Auto Spin';
        if(AUTO_SPIN_ON){
          // if input had a value, use it; otherwise keep existing autoSpinCount
          const inputVal = Number((autoCountEl && autoCountEl.value) || 0) || 0; if(inputVal>0) autoSpinCount = Math.max(0, Math.floor(inputVal));
          // start interval loop
          _autoSpinInterval = setInterval(async ()=>{
            // safety: stop if balance insufficient and not in free spins
            if(!inFreeSpins && balance < betPerSpin){ AUTO_SPIN_ON=false; autoBtn.textContent='Auto Spin'; clearInterval(_autoSpinInterval); _autoSpinInterval=null; return; }
            // disable auto if user manually toggles buttons
            if(document.getElementById('spin').disabled) return;
            await spin();
            if(autoSpinCount>0){ autoSpinCount = Math.max(0, autoSpinCount - 1); if(autoSpinCount === 0){ AUTO_SPIN_ON=false; autoBtn.textContent='Auto Spin'; clearInterval(_autoSpinInterval); _autoSpinInterval=null; } }
          }, AUTO_SPIN_DELAY);
        } else { if(_autoSpinInterval){ clearInterval(_autoSpinInterval); _autoSpinInterval=null; } }
      }); }
      const buyBtnEl = document.getElementById('buyBonus'); if(buyBtnEl) buyBtnEl.addEventListener('click', ()=>{
        const cost = betPerSpin * 100;
        if(balance < cost){ alert('Not enough to buy bonus (cost: '+cost.toFixed(2)+')'); return; }
        balance -= cost;
        inFreeSpins=true; freeSpins = Math.min(100, freeSpins + 15); updateUI();
      });
      const toggleAnteEl = document.getElementById('toggleAnte'); if(toggleAnteEl) toggleAnteEl.addEventListener('click', ()=>{ anteOn = !anteOn; updateUI(); });
      const betPlusEl = document.getElementById('betPlus'); if(betPlusEl) betPlusEl.addEventListener('click', ()=>{ betPerSpin = Math.min(MAX_BET, +(betPerSpin + BET_STEP).toFixed(2)); updateUI(); });
      const betMinusEl = document.getElementById('betMinus'); if(betMinusEl) betMinusEl.addEventListener('click', ()=>{ betPerSpin = Math.max(MIN_BET, +(betPerSpin - BET_STEP).toFixed(2)); updateUI(); });
    });

    if(leftInfo) leftInfo.innerHTML = 'Reels: 5×3 payline mode (10 paylines, min 3 on a payline).';
    // initial seed: prefer local crypto (no UI controls)
    if(window._seedFromCrypto) window._seedFromCrypto();
    // initialize reels
    if(typeof initReelStrips==='function') initReelStrips();
    // no beacon saved (local-only mode)
  </script>
  <!-- tweetnacl removed: no external beacon verification -->
</body>
</html>
