<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discord Slot â€“ Gates-Style Pay-Anywhere con Tumble</title>
  <style>
    :root {
      --cell-size: min(14vw, 110px);
      --bg: #050608;
      --card-bg: #1f2027;
      --card-border: #2a2b33;
      --accent: #6c63ff;
      --accent-soft: #8b83ff;
      --text-main: #f4f6fb;
      --text-muted: #b0b3bd;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #151824, #050608 60%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 24px 12px;
    }

    h1 {
      margin-bottom: 0.2rem;
      text-align: center;
      font-size: clamp(1.6rem, 4vw, 2.1rem);
      text-shadow: 0 0 18px rgba(0, 0, 0, 0.7);
    }

    p.subtitle {
      margin-top: 0;
      margin-bottom: 0.9rem;
      font-size: 0.9rem;
      opacity: 0.9;
      text-align: center;
      color: var(--text-muted);
    }

    .slot-wrapper {
      background: radial-gradient(circle at top, #292b3a, #181924 60%);
      border-radius: 22px;
      padding: 18px;
      border: 1px solid var(--card-border);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      max-width: 1000px;
    }

    .slot-frame {
      position: relative;
      display: inline-block;
    }

    .slot-container {
      display: grid;
      grid-template-columns: repeat(6, var(--cell-size));
      grid-template-rows: repeat(5, var(--cell-size));
      gap: 10px;
      padding: 14px;
      background: linear-gradient(180deg,#0f1116,#0b0c11);
      border-radius: 18px;
      box-shadow: inset 0 6px 18px rgba(0, 0, 0, 0.7);
      justify-content: center;
      position: relative;
      z-index: 1;
    }

    .slot-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      background: linear-gradient(180deg,#0a0b0f,#07080b);
      border-radius: 14px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.65);
    }

    .slot-cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition:
        transform 0.18s ease,
        box-shadow 0.18s ease,
        outline 0.18s ease,
        filter 0.18s ease;
    }

    .slot-cell img.pop-out {
      animation: pop-out 0.26s ease forwards;
      filter: saturate(1.5);
    }

    @keyframes pop-out {
      0% {
        transform: scale(1) translateY(0);
        opacity: 1;
      }
      100% {
        transform: scale(0.6) translateY(-10px);
        opacity: 0;
      }
    }

    .slot-cell img.win {
      transform: scale(1.06);
      outline: 3px solid var(--win-color, #ffd700);
      box-shadow:
        0 0 16px rgba(0, 0, 0, 0.8),
        0 0 18px var(--win-color, #ffd700);
      filter: saturate(1.25);
    }

    .paylines-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      overflow: visible;
    }

    .info-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px 18px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .info-block {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .info-label {
      opacity: 0.8;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 4px;
    }

    /* play bar (compact controls sotto la slot) */
    .play-bar {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-top: 10px;
      padding: 14px 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .controls-play { display:flex; gap:10px; align-items:center; }
    .toggles { display:flex; gap:12px; align-items:center }
    .play-area .bet { margin-right:12px; }
    .controls.compact { display:none; }

    .bottom-row {
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-top:10px;
    }
    .sim-controls { display:flex; gap:8px; align-items:center; }
    .input-short { width:110px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:#0e0f13; color:var(--text-main); }
    .rtp-result { color:var(--text-muted); min-width:220px; text-align:center; }
    .rtp-result strong { color: var(--accent); font-weight:800; }
    .status-compact { color:var(--text-muted); display:flex; gap:8px; align-items:center; }
    .value-compact { font-weight:700; color:var(--text-main); }

    .play-area {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .play-area .step {
      padding: 0.2rem 0.6rem;
      font-size: 0.95rem;
    }

    .currency {
      font-weight: 700;
      min-width: 86px;
      text-align: center;
    }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .toggle button {
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #2b2d38;
      color: #fff;
      font-weight: 600;
    }

    .toggle button.active {
      background: var(--accent);
      box-shadow: 0 6px 14px rgba(88,101,242,0.28);
    }

    .play-btn {
      padding: 0.6rem 1.1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: 800;
      background: linear-gradient(180deg,var(--accent),var(--accent-soft));
      color: white;
      box-shadow: 0 14px 30px rgba(108,99,255,0.18);
      letter-spacing: .4px;
    }

    /* improved control buttons */
    .btn-primary, .btn-secondary, .step {
      border: none;
      background: #2b2d38;
      color: var(--text-main);
      padding: 0.5rem 0.7rem;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      transition: transform .08s ease, box-shadow .12s ease, background .12s ease;
    }

    .btn-primary {
      background: linear-gradient(180deg,var(--accent),var(--accent-soft));
      box-shadow: 0 14px 28px rgba(108,99,255,0.16);
      color: white;
      padding: 0.65rem 0.95rem;
      border-radius: 14px;
      font-weight:800;
    }

    .btn-secondary {
      background: linear-gradient(180deg,#33343c,#2b2d38);
      color: var(--text-main);
      padding: 0.5rem 0.85rem;
    }

    .step:hover, .btn-secondary:hover, .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.6);
    }

    .step:active, .btn-secondary:active, .btn-primary:active {
      transform: translateY(0px) scale(.995);
    }

    .step[disabled] { opacity: 0.5; cursor: not-allowed; }

    /* tooltips removed per user request */

    /* focus styles for accessibility */
    .btn-primary:focus, .btn-secondary:focus, .step:focus {
      outline: 3px solid rgba(88,101,242,0.22);
      outline-offset: 3px;
    }

    .bet {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 0.9rem;
    }

    .bet button.step {
      padding: 0.1rem 0.55rem;
      font-size: 0.9rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #323347;
      color: #fff;
      font-weight: 600;
    }

    .bet span.value {
      min-width: 2.4rem;
      text-align: center;
      display: inline-block;
      font-variant-numeric: tabular-nums;
    }

    .btn-primary,
    .btn-secondary {
      padding: 0.5rem 1.4rem;
      font-size: 1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition:
        background 0.15s ease,
        transform 0.1s ease,
        box-shadow 0.15s ease;
    }

    .btn-primary {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 8px 18px rgba(88, 101, 242, 0.45);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent-soft);
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(88, 101, 242, 0.6);
    }

    .btn-secondary {
      background: #333548;
      color: #e5e7ff;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #3c3f58;
      transform: translateY(-1px);
    }

    button:disabled {
      background: #3a3a47 !important;
      cursor: not-allowed;
      box-shadow: none !important;
      transform: none !important;
    }

    .message {
      min-height: 1.4rem;
      max-width: 620px;
      text-align: center;
      font-size: 0.9rem;
      margin-top: 6px;
      color: var(--text-muted);
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));
      padding: 8px 12px;
      border-radius: 8px;
    }

    .message--win {
      color: #b8ffb2;
    }

    .message--nice {
      color: #ffe66d;
    }

    .message--bigwin {
      color: #ffd166;
      font-weight: 600;
      font-size: 1rem;
    }

    .message--error {
      color: #ff7b7b;
    }

    .message--bonus {
      color: #ffdd6f;
    }

    @media (max-width: 600px) {
      .slot-wrapper {
        padding: 14px;
      }

      .slot-container {
        padding: 8px;
        gap: 6px;
      }

      .btn-primary,
      .btn-secondary {
        padding: 0.45rem 1.1rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <h1>Discord Slot â€“ Gates Of Olympus Style (6Ã—5 Pay-Anywhere)</h1>
  <p class="subtitle">
    Pay-anywhere 6Ã—5 con tumble, scatter per i free spin e moltiplicatori casuali.
  </p>

  <div class="slot-wrapper">
    <div class="slot-frame">
      <div class="slot-container">
        <!-- 5 righe x 6 colonne = 30 slot (0â€“29) -->
        <div class="slot-cell"><img id="slot-0" src="img/user1.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-1" src="img/user2.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-2" src="img/user3.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-3" src="img/user4.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-4" src="img/user5.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-5" src="img/user6.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-6" src="img/user7.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-7" src="img/user8.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-8" src="img/user9.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-9" src="img/user10.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-10" src="img/user1.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-11" src="img/user2.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-12" src="img/user3.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-13" src="img/user4.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-14" src="img/user5.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-15" src="img/user6.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-16" src="img/user7.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-17" src="img/user8.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-18" src="img/user9.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-19" src="img/user10.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-20" src="img/user1.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-21" src="img/user2.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-22" src="img/user3.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-23" src="img/user4.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-24" src="img/user5.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-25" src="img/user6.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-26" src="img/user7.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-27" src="img/user8.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-28" src="img/user9.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-29" src="img/user10.png" alt="" /></div>
      </div>
      <svg id="paylinesSvg" class="paylines-svg"></svg>
    </div>

    <div class="info-row">
      <div class="info-block">
        <span class="info-label">Crediti:</span>
        <span id="credits">1000</span>
      </div>
      <div class="info-block">
        <span class="info-label">ModalitÃ :</span>
        <span id="mode">Base</span>
        <span class="info-label">| Free spin:</span>
        <span id="fs-count">0</span>
      </div>
      <div class="info-block">
        <span class="info-label">Ultima vincita:</span>
        <span id="last-win">0</span>
      </div>
      <div class="info-block">
        <span class="info-label">Schema:</span>
        <span id="info-lines">Pay-anywhere</span>
      </div>
      <div class="info-block">
        <span class="info-label">RTP simulato:</span>
        <span id="info-rtp">~96% (20k spin)</span>
      </div>
    </div>

    <!-- compact controls removed to declutter; main actions moved into play-bar for clarity -->

    <div class="play-bar" id="playBar">
      <div class="play-area">
        <div class="currency">â‚¬ <span id="display-credits">0.00</span></div>
        <div class="bet">Puntata base: <button class="step" id="bet-minus">âˆ’</button> <span id="bet-per-line" class="value">1.00</span> <button class="step" id="bet-plus">+</button></div>
        <div class="bet">Pay-anywhere</div>
        <div class="bet">Totale: <span id="total-bet" class="value">1.00</span></div>
      </div>

      <div class="controls-play">
        <button class="btn-primary" id="spinBtn">SPIN</button>
        <button class="btn-secondary" id="autoBtn">AUTO</button>
        <button class="btn-secondary" id="resetBtn">RESET</button>
      </div>

      <div class="toggles">
        <div class="toggle"><label for="turboBtn">TURBO</label><button id="turboBtn" aria-pressed="false" aria-label="Toggle turbo">T</button></div>
        <div class="toggle"><label for="autoToggle">AUTOMATICO</label><button id="autoToggle" aria-pressed="false" aria-label="Toggle auto">A</button></div>
      </div>
    </div>

    <div class="bottom-row">
      <div class="sim-controls">
        <label class="info-label" for="rtp-count">Simulazioni</label>
        <input id="rtp-count" type="number" value="100000" min="1000" step="1000" class="input-short" />
        <button id="rtpBtn" class="step">Calcola RTP</button>
        <div id="rtpResult" class="rtp-result">RTP: â€”</div>
      </div>

      <div class="status-compact">
        <span class="info-label">Crediti:</span>
        <span id="creditsCompact" class="value-compact">0.00</span>
        <span class="sep">â€¢</span>
        <span class="info-label">ModalitÃ :</span>
        <span id="modeCompact" class="value-compact">Base</span>
      </div>
    </div>

    <div class="message" id="message"></div>
  </div>

  <script>
    // ---- CONFIG ---------------------------------------------------------

    const members = [
      { name: "User1", img: "img/user1.png" },
      { name: "User2", img: "img/user2.png" },
      { name: "User3", img: "img/user3.png" },
      { name: "User4", img: "img/user4.png" },
      { name: "User5", img: "img/user5.png" },
      { name: "User6", img: "img/user6.png" },
      { name: "User7", img: "img/user7.png" },
      { name: "User8", img: "img/user8.png" },
      { name: "User9", img: "img/user9.png" },
      { name: "User10", img: "img/user10.png" },
      { name: "User11", img: "img/user11.png" },
      { name: "User12", img: "img/user12.png" }
    ];

    const SCATTER = {
      name: "SCATTER",
      img: "img/scatter.png",
      isScatter: true
    };

    const MULT_BASE = {
      name: "MULT",
      img: "img/multi.png",
      isMultiplier: true
    };

    const ROWS = 5;
    const COLS = 6;
    const TOTAL_SLOTS = ROWS * COLS;

    // for Gates-like behaviour we use pay-anywhere: counts across the whole panel
    const PAY_ANYWHERE = true;
    const TOTAL_LINES = 1; // stake unico su schema pay-anywhere

    // paytable ufficiale (Gates-style) espresso come multipli della puntata totale
    const PAYTABLE = {
      User1: { 8: 12, 10: 30, 12: 50 }, // corona
      User2: { 8: 3, 10: 10, 12: 25 }, // anello
      User3: { 8: 2.4, 10: 5, 12: 10 }, // clessidra
      User4: { 8: 1.5, 10: 4, 12: 8 }, // calice
      User5: { 8: 1, 10: 2.4, 12: 5 }, // gemma rossa
      User6: { 8: 0.8, 10: 2, 12: 4 }, // gemma gialla
      User7: { 8: 0.6, 10: 1.5, 12: 3 }, // gemma verde
      User8: { 8: 0.4, 10: 1, 12: 2.4 }, // gemma blu
      User9: { 8: 0.4, 10: 1, 12: 2.4 },
      User10: { 8: 0.4, 10: 1, 12: 2.4 },
      User11: { 8: 0.4, 10: 1, 12: 2.4 },
      User12: { 8: 0.4, 10: 1, 12: 2.4 }
    };

    const SCATTER_PAYOUT = { 4: 60, 5: 100, 6: 200 };

    const FREE_SPIN_TRIGGER = 4;
    const BASE_FREE_SPINS = 15;
    const RETRIGGER_SCATTERS = 3;
    const RETRIGGER_SPINS = 5;
    const MULT_VALUES = [
      2, 3, 4, 5, 6, 8, 10, 12, 15, 20, 25, 50, 100, 250, 500
    ];

    // distribuzione simboli (scatter / multiplier piÃ¹ rari)
    const WEIGHTED_SYMBOLS = [];
    members.forEach((m) => {
      WEIGHTED_SYMBOLS.push({ symbol: m, weight: 6 });
    });
    WEIGHTED_SYMBOLS.push({ symbol: SCATTER, weight: 1.5 });
    WEIGHTED_SYMBOLS.push({ symbol: MULT_BASE, weight: 1 });

    const LINE_COLORS = [
      "#ffb703",
      "#4cc9f0",
      "#ff595e",
      "#b8ff5c",
      "#f72585",
      "#ffd166",
      "#06d6a0",
      "#a0c4ff",
      "#ffadad",
      "#c77dff"
    ];

    const STORAGE_KEY = "discord_slot_10lines_wsm_v1";
    let turboMode = false;

    // ---- STATO ----------------------------------------------------------

    let credits = 1000.0;
    let betPerLine = 1.0;
    const MIN_BET_PER_LINE = 0.01; // allow betting cents
    const BET_STEP = 0.01;
    const MAX_BET_PER_LINE = 100;

    let activeLines = TOTAL_LINES;
    const MIN_LINES = TOTAL_LINES;
    const MAX_LINES = TOTAL_LINES;

    let autoSpinCount = 10;
    const MIN_AUTO = 10;
    const MAX_AUTO = 100;
    const AUTO_STEP = 10;

    let autoSpinsLeft = 0;
    let lastWin = 0;

    let inFreeSpins = false;
    let freeSpins = 0;
    let bonusBetPerLine = 1;
    let bonusLines = TOTAL_LINES;
    let globalMultiplier = 1;

    // ---- DOM ------------------------------------------------------------

    const creditsEl = document.getElementById("credits");
    const modeEl = document.getElementById("mode");
    const fsCountEl = document.getElementById("fs-count");
    const lastWinEl = document.getElementById("last-win");
    const infoLinesEl = document.getElementById("info-lines");

    const messageEl = document.getElementById("message");
    const spinBtn = document.getElementById("spinBtn");
    const autoBtn = document.getElementById("autoBtn");
    const resetBtn = document.getElementById("resetBtn");

    const betMinusBtn = document.getElementById("bet-minus");
    const betPlusBtn = document.getElementById("bet-plus");
    const betPerLineEl = document.getElementById("bet-per-line");
    const totalBetEl = document.getElementById("total-bet");

    const linesMinusBtn = document.getElementById("lines-minus");
    const linesPlusBtn = document.getElementById("lines-plus");
    const linesCountEl = document.getElementById("lines-count");

    const autoMinusBtn = document.getElementById("auto-minus");
    const autoPlusBtn = document.getElementById("auto-plus");
    const autoCountEl = document.getElementById("auto-count");

    const slotContainer = document.querySelector(".slot-container");
    const paylinesSvg = document.getElementById("paylinesSvg");
    const displayCreditsEl = document.getElementById("display-credits");
    const betTotalMinusBtn = document.getElementById("bet-total-minus");
    const betTotalPlusBtn = document.getElementById("bet-total-plus");
    const betTotalDisplay = document.getElementById("bet-total-display");
    const turboBtn = document.getElementById("turboBtn");
    const autoToggleBtn = document.getElementById("autoToggle");
    const playSmallBtn = document.getElementById("playSmall");

    // ---- UTIL -----------------------------------------------------------

    function saveState() {
      try {
        const state = {
          credits,
          betPerLine,
          activeLines,
          autoSpinCount,
          turboMode
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch {}
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const state = JSON.parse(raw);
        if (typeof state.credits === "number") credits = state.credits;
        if (typeof state.betPerLine === "number") {
          betPerLine = Math.min(
            MAX_BET_PER_LINE,
            Math.max(MIN_BET_PER_LINE, state.betPerLine)
          );
        }
        if (typeof state.activeLines === "number") {
          activeLines = Math.min(
            MAX_LINES,
            Math.max(MIN_LINES, state.activeLines)
          );
        }
        if (typeof state.autoSpinCount === "number") {
          autoSpinCount = Math.min(
            MAX_AUTO,
            Math.max(MIN_AUTO, state.autoSpinCount)
          );
        }
        if (typeof state.turboMode === "boolean") {
          turboMode = state.turboMode;
        }
      } catch {}
    }

    function getCurrentBetPerLine() {
      return inFreeSpins ? bonusBetPerLine : betPerLine;
    }

    function getCurrentLines() {
      return inFreeSpins ? bonusLines : activeLines;
    }

    function formatCurrency(n) {
      return Number(n).toFixed(2);
    }

    function updateCredits() {
      creditsEl.textContent = formatCurrency(credits);
      if (displayCreditsEl) displayCreditsEl.textContent = formatCurrency(credits);
      const creditsCompact = document.getElementById('creditsCompact');
      if (creditsCompact) creditsCompact.textContent = formatCurrency(credits);
    }

    function updateMode() {
      modeEl.textContent = inFreeSpins ? "Bonus (Free Spin)" : "Base";
      fsCountEl.textContent = freeSpins;
      const modeCompact = document.getElementById('modeCompact');
      if (modeCompact) modeCompact.textContent = inFreeSpins ? "Bonus" : "Base";
    }

    function updateLastWin() {
      lastWinEl.textContent = formatCurrency(lastWin);
    }

    function updateBetDisplay() {
      betPerLineEl.textContent = formatCurrency(betPerLine);
      totalBetEl.textContent = formatCurrency(betPerLine * activeLines);
      if (betTotalDisplay) betTotalDisplay.textContent = formatCurrency(betPerLine * activeLines);
    }

    function updateLinesDisplay() {
      if (linesCountEl) linesCountEl.textContent = `${activeLines} (pay-anywhere)`;
      infoLinesEl.textContent = "Pay-anywhere";
      totalBetEl.textContent = formatCurrency(betPerLine * activeLines);
      if (betTotalDisplay) betTotalDisplay.textContent = formatCurrency(betPerLine * activeLines);
    }

    function updateAutoCountDisplay() {
      autoCountEl.textContent = autoSpinCount;
    }

    function updateAutoLabel() {
      autoBtn.textContent =
        autoSpinsLeft > 0 ? `AUTO (${autoSpinsLeft})` : "AUTO";
    }

    function setMessage(text, type = "normal") {
      messageEl.textContent = text;
      messageEl.className = "message";
      if (type && type !== "normal") {
        messageEl.classList.add(`message--${type}`);
      }
    }

    function rollMultiplierValue() {
      const idx = Math.floor(Math.random() * MULT_VALUES.length);
      return MULT_VALUES[idx];
    }

    function randomSymbol() {
      const total = WEIGHTED_SYMBOLS.reduce((sum, e) => sum + e.weight, 0);
      let r = Math.random() * total;
      for (const entry of WEIGHTED_SYMBOLS) {
        if (r < entry.weight) {
          if (entry.symbol.isMultiplier) {
            const value = rollMultiplierValue();
            return { ...entry.symbol, value, name: `MULT x${value}` };
          }
          return entry.symbol;
        }
        r -= entry.weight;
      }
      return WEIGHTED_SYMBOLS[0].symbol;
    }

    function setSlotImage(slotIndex, symbol) {
      const img = document.getElementById(`slot-${slotIndex}`);
      img.src = symbol.img;
      img.alt = symbol.isMultiplier ? `Moltiplicatore x${symbol.value}` : symbol.name;
    }

    function clearPaylines() {
      if (paylinesSvg) {
        paylinesSvg.innerHTML = "";
      }
    }

    function clearWins() {
      const imgs = document.querySelectorAll(".slot-cell img");
      imgs.forEach((img) => {
        img.classList.remove("win");
        img.style.removeProperty("--win-color");
      });
      clearPaylines();
    }

    function markIndices(indices, color) {
      indices.forEach((index) => {
        const img = document.getElementById(`slot-${index}`);
        img.classList.add("win");
        if (color) {
          img.style.setProperty("--win-color", color);
        }
      });
    }

    function getSlotCenter(index) {
      const img = document.getElementById(`slot-${index}`);
      const imgRect = img.getBoundingClientRect();
      const contRect = slotContainer.getBoundingClientRect();
      return {
        x: imgRect.left - contRect.left + imgRect.width / 2,
        y: imgRect.top - contRect.top + imgRect.height / 2
      };
    }

    function drawPaylines(lines) {
      clearPaylines();
      if (!lines.length) return;

      const width = slotContainer.clientWidth;
      const svgNS = "http://www.w3.org/2000/svg";

      paylinesSvg.setAttribute("width", width);
      paylinesSvg.setAttribute("height", slotContainer.clientHeight);
      paylinesSvg.setAttribute(
        "viewBox",
        `0 0 ${slotContainer.clientWidth} ${slotContainer.clientHeight}`
      );

      lines.forEach((line) => {
        const poly = document.createElementNS(svgNS, "polyline");
        const points = line.lineSlots
          .map((i) => {
            const c = getSlotCenter(i);
            return `${c.x},${c.y}`;
          })
          .join(" ");
        poly.setAttribute("points", points);
        poly.setAttribute("stroke", line.color || "#ffd700");
        poly.setAttribute("stroke-width", "4");
        poly.setAttribute("fill", "none");
        poly.setAttribute("stroke-linecap", "round");
        poly.setAttribute("stroke-linejoin", "round");
        poly.setAttribute("stroke-dasharray", "9 6");
        paylinesSvg.appendChild(poly);
      });
    }

    function payoutForCount(symbolName, count) {
      const table = PAYTABLE[symbolName];
      if (!table) return 0;
      const thresholds = Object.keys(table)
        .map(Number)
        .sort((a, b) => a - b);
      let matched = 0;
      thresholds.forEach((t) => {
        if (count >= t) matched = t;
      });
      return matched ? table[matched] : 0;
    }

    function payoutForScatter(count) {
      if (count >= 6) return SCATTER_PAYOUT[6];
      if (count >= 5) return SCATTER_PAYOUT[5];
      if (count >= 4) return SCATTER_PAYOUT[4];
      return 0;
    }

    function collectWins(grid, includeScatter = true) {
      const counts = new Map();
      const multiplierIndices = [];
      let multiplierSum = 0;
      const scatterCount = grid.filter((s) => s.isScatter).length;
      const scatterWin = includeScatter ? payoutForScatter(scatterCount) : 0;

      grid.forEach((sym, idx) => {
        if (sym.isScatter) return;
        if (sym.isMultiplier) {
          multiplierIndices.push(idx);
          multiplierSum += sym.value || 0;
          return;
        }
        if (!counts.has(sym.name)) counts.set(sym.name, []);
        counts.get(sym.name).push(idx);
      });

      const wins = [];
      const removeIndices = new Set();
      let baseWin = scatterWin;

      counts.forEach((indices, name) => {
        const payoutMult = payoutForCount(name, indices.length);
        if (payoutMult > 0) {
          wins.push({ symbol: name, count: indices.length, payoutMult, indices });
          indices.forEach((i) => removeIndices.add(i));
          baseWin += payoutMult;
        }
      });

      return {
        wins,
        removeIndices,
        baseWin,
        multiplierSum,
        multiplierIndices,
        scatterCount,
        scatterWin
      };
    }

    function applyTumble(grid, removeSet) {
      const newGrid = [...grid];
      const dropDistances = Array(grid.length).fill(0);
      const newSymbolFlags = Array(grid.length).fill(false);

      for (let c = 0; c < COLS; c++) {
        const kept = [];
        const dist = [];
        let emptyBelow = 0;

        for (let r = ROWS - 1; r >= 0; r--) {
          const idx = r * COLS + c;
          if (removeSet.has(idx)) {
            emptyBelow++;
            continue;
          }
          kept.push(grid[idx]);
          dist.push(emptyBelow);
        }

        while (kept.length < ROWS) {
          kept.push(randomSymbol());
          dist.push(ROWS); // spawn from above the grid for a visible fall
        }

        for (let r = ROWS - 1; r >= 0; r--) {
          const idx = r * COLS + c;
          const arrIdx = ROWS - 1 - r;
          newGrid[idx] = kept[arrIdx];
          dropDistances[idx] = dist[arrIdx];
          newSymbolFlags[idx] = dist[arrIdx] >= ROWS;
        }
      }
      return { grid: newGrid, dropDistances, newSymbolFlags };
    }

    // animazione rulli
    function spinAnimation(finalSymbols, onComplete) {
      const columns = [];
      for (let c = 0; c < COLS; c++) {
        const colIndices = [];
        for (let r = 0; r < ROWS; r++) {
          colIndices.push(r * COLS + c);
        }
        columns.push(colIndices);
      }
      let finishedColumns = 0;
      const steps = turboMode ? 3 : 4;
      const stepDuration = turboMode ? 70 : 120;

      columns.forEach((indices, colIndex) => {
        const startDelay = colIndex * (turboMode ? 80 : 140);
        setTimeout(() => {
          let step = 0;
          const interval = setInterval(() => {
            indices.forEach((i) => setSlotImage(i, randomSymbol()));
            step++;
            if (step >= steps) {
              clearInterval(interval);
              indices.forEach((i) => setSlotImage(i, finalSymbols[i]));
              finishedColumns++;
              if (finishedColumns === columns.length) {
                onComplete();
              }
            }
          }, stepDuration);
        }, startDelay);
      });
    }

    // ---- LOGICA DI GIOCO -----------------------------------------------

    function spinOnce(fromAuto = false) {
      if (inFreeSpins && freeSpins <= 0) {
        inFreeSpins = false;
        globalMultiplier = 1;
        updateMode();
      }

      const wasFreeSpin = inFreeSpins;

      if (fromAuto && !wasFreeSpin) {
        if (autoSpinsLeft <= 0) {
          updateAutoLabel();
          return;
        }
        autoSpinsLeft--;
        updateAutoLabel();
      }

      const currentBetPerLine = getCurrentBetPerLine();
      const currentLines = getCurrentLines();
      let betTotal = 0;

      if (!wasFreeSpin) {
        betTotal = currentBetPerLine * currentLines;
        if (credits < betTotal) {
          setMessage("Non hai abbastanza crediti per questa puntata.", "error");
          autoSpinsLeft = 0;
          updateAutoLabel();
          return;
        }
        credits -= betTotal;
        updateCredits();
        saveState();
      } else {
        if (freeSpins > 0) {
          freeSpins--;
        }
      }

      updateMode();
      setMessage("");
      clearWins();

      spinBtn.disabled = true;
      autoBtn.disabled = true;

      const finalSymbols = [];
      for (let i = 0; i < TOTAL_SLOTS; i++) {
        finalSymbols.push(randomSymbol(i));
      }

      spinAnimation(finalSymbols, async () => {
        try {
          await evaluateResult(
            finalSymbols,
            betTotal,
            currentBetPerLine,
            currentLines,
            wasFreeSpin
          );
        } catch (err) {
          console.error("Error in evaluateResult:", err);
          setMessage("Errore interno durante la risoluzione del giro. Riprova.", "error");
        } finally {
          // ensure UI is always re-enabled so user can continue
          try {
            if (spinBtn) spinBtn.disabled = false;
            if (autoBtn) autoBtn.disabled = false;
          } catch (e) {
            console.error("Error re-enabling buttons:", e);
          }
        }

        if (autoSpinsLeft > 0 && !inFreeSpins) {
          const nextBet = betPerLine * activeLines;
          if (credits >= nextBet) {
            setTimeout(() => spinOnce(true), 450);
          } else {
            autoSpinsLeft = 0;
            updateAutoLabel();
            setMessage(
              "Auto-spin fermato: crediti insufficienti.",
              "error"
            );
          }
        }
      });
    }

    function animateRemovals(indices) {
      indices.forEach((i) => {
        const img = document.getElementById(`slot-${i}`);
        img.classList.add("pop-out");
      });
    }

    function animateTumbleTransition(newGrid, dropDistances, newSymbolFlags) {
      const cell = document.querySelector(".slot-cell");
      const gap = parseFloat(getComputedStyle(slotContainer).gap || "0");
      const unit = (cell?.clientHeight || 100) + gap;
      const dropDuration = turboMode ? 150 : 260;

      return new Promise((resolve) => {
        requestAnimationFrame(() => {
          for (let i = 0; i < newGrid.length; i++) {
            const img = document.getElementById(`slot-${i}`);
            img.classList.remove("win", "pop-out");
            img.style.transition = "none";
            const distance = dropDistances?.[i] || 0;
            const fromY = -distance * unit;
            img.style.transform = `translateY(${fromY}px)`;
            img.style.opacity = newSymbolFlags?.[i] ? 0 : 1;
            setSlotImage(i, newGrid[i]);
          }

          // force layout so the browser recognizes the pre-drop position
          slotContainer.getBoundingClientRect();

          requestAnimationFrame(() => {
            for (let i = 0; i < newGrid.length; i++) {
              const img = document.getElementById(`slot-${i}`);
              img.style.transition = `transform ${dropDuration}ms ease, opacity ${dropDuration}ms ease`;
              img.style.transform = "translateY(0)";
              img.style.opacity = 1;
            }
          });
        });

        setTimeout(resolve, dropDuration + 40);
      });
    }

    async function evaluateResult(
      resultSymbols,
      betTotal,
      currentBetPerLine,
      currentLines,
      wasFreeSpin
    ) {
      let grid = [...resultSymbols];
      let spinTotal = 0;
      let tumbleStep = 0;
      let includeScatter = true;

      while (true) {
        const {
          wins,
          removeIndices,
          baseWin,
          multiplierSum,
          multiplierIndices,
          scatterCount,
          scatterWin
        } = collectWins(grid, includeScatter);
        includeScatter = false;
        if (baseWin <= 0) break;

        let stepWin = baseWin * currentBetPerLine;
        let appliedMultiplier = 1;
        if (multiplierSum > 0) {
          appliedMultiplier = multiplierSum;
          stepWin *= appliedMultiplier;
          if (inFreeSpins) globalMultiplier += multiplierSum;
        }
        if (inFreeSpins) stepWin *= globalMultiplier;

        spinTotal += stepWin;
        lastWin = spinTotal;
        updateLastWin();

        const highlightIndices = new Set(removeIndices);
        if (baseWin > 0 && multiplierSum > 0) {
          multiplierIndices.forEach((i) => highlightIndices.add(i));
        }
        const winParts = wins.map((w) => `${w.count}Ã— ${w.symbol}`);
        if (scatterWin > 0) winParts.push(`${scatterCount}Ã— SCATTER`);
        markIndices(Array.from(highlightIndices), LINE_COLORS[tumbleStep % LINE_COLORS.length]);

        const winText = winParts.join(" + ");
        const multiplierText = multiplierSum > 0 ? ` Ã—${appliedMultiplier}${inFreeSpins ? ` (globale x${globalMultiplier.toFixed(2)})` : ""}` : "";
        setMessage(
          `Tumble ${tumbleStep + 1}: ${winText} â†’ +${formatCurrency(stepWin)}${multiplierText}`,
          stepWin >= betTotal * 5 ? "bigwin" : "win"
        );

        const removeSet = new Set(highlightIndices);
        if (removeSet.size === 0) break; // scatter-only payout, no tumble to apply

        animateRemovals(Array.from(removeSet));
        await new Promise((r) => setTimeout(r, turboMode ? 80 : 220));

        const { grid: nextGrid, dropDistances, newSymbolFlags } = applyTumble(
          grid,
          removeSet
        );

        await animateTumbleTransition(nextGrid, dropDistances, newSymbolFlags);
        grid = nextGrid;
        tumbleStep++;
        await new Promise((r) => setTimeout(r, turboMode ? 60 : 140));
        clearWins();
      }

      const finalScatterCount = grid.filter((s) => s.isScatter).length;

      if (spinTotal > 0) {
        credits += spinTotal;
        updateCredits();
        saveState();
      }

      // scatter trigger after tumbles conclude
      if (!inFreeSpins && finalScatterCount >= FREE_SPIN_TRIGGER) {
        const awarded = BASE_FREE_SPINS;
        freeSpins = Math.min(100, freeSpins + awarded);
        inFreeSpins = true;
        globalMultiplier = 1;
        bonusBetPerLine = currentBetPerLine;
        bonusLines = currentLines;
        autoSpinsLeft = 0;
        updateAutoLabel();
        setMessage(
          `Bonus attivato! ${finalScatterCount} scatter â†’ ${awarded} free spin. Moltiplicatore globale attuale: x${globalMultiplier.toFixed(2)}.`,
          "bonus"
        );
      } else if (inFreeSpins && finalScatterCount >= RETRIGGER_SCATTERS) {
        freeSpins = Math.min(100, freeSpins + RETRIGGER_SPINS);
        setMessage(
          `Retrigger! ${finalScatterCount} scatter â†’ +${RETRIGGER_SPINS} free spin (totale ${freeSpins}). Moltiplicatore globale: x${globalMultiplier.toFixed(2)}.`,
          "bonus"
        );
      } else if (spinTotal === 0) {
        if (wasFreeSpin && freeSpins > 0) setMessage(`Free spin senza vincita. Free spin rimasti: ${freeSpins}`);
        else if (wasFreeSpin && freeSpins === 0) {
          inFreeSpins = false;
          globalMultiplier = 1;
          updateMode();
          setMessage("Fine modalitÃ  bonus, si torna al gioco base.");
        } else setMessage("Nessuna combinazioneâ€¦ ritenta ðŸ˜ˆ");
      }

      lastWin = spinTotal;
      updateLastWin();
      updateMode();

      if (inFreeSpins && freeSpins <= 0 && finalScatterCount < FREE_SPIN_TRIGGER) {
        inFreeSpins = false;
        globalMultiplier = 1;
        updateMode();
      }
    }

    // --- Simulazione (versione headless per RTP estimation)
    function resolveSpinSimulation(currentBetPerLine, currentLines, inBonus = false, startingGlobal = 1) {
      let grid = randomFinalSymbols();
      let total = 0;
      let globalSim = startingGlobal;
      let includeScatter = true;

      while (true) {
        const {
          baseWin,
          multiplierSum,
          removeIndices,
          multiplierIndices,
          scatterCount
        } = collectWins(grid, includeScatter);
        includeScatter = false;
        if (baseWin <= 0) break;
        let step = baseWin * currentBetPerLine;
        if (multiplierSum > 0) {
          step *= multiplierSum;
          if (inBonus) globalSim += multiplierSum;
        }
        if (inBonus) step *= globalSim;
        total += step;
        const removeSet = new Set(removeIndices);
        if (baseWin > 0 && multiplierSum > 0) multiplierIndices.forEach((i) => removeSet.add(i));
        if (removeSet.size === 0) break;
        grid = applyTumble(grid, removeSet);
      }

      const finalScatterCount = grid.filter((s) => s.isScatter).length;
      const freeSpinsAwarded = !inBonus && finalScatterCount >= FREE_SPIN_TRIGGER
        ? BASE_FREE_SPINS
        : 0;
      const retriggerSpins = inBonus && finalScatterCount >= RETRIGGER_SCATTERS
        ? RETRIGGER_SPINS
        : 0;

      return { win: total, freeSpinsAwarded, retriggerSpins, globalSim };
    }

    function randomFinalSymbols() {
      const finalSymbols = [];
      for (let i = 0; i < TOTAL_SLOTS; i++) finalSymbols.push(randomSymbol());
      return finalSymbols;
    }

    async function estimateRTP(spins, betPerLineForSim = betPerLine, linesForSim = activeLines, onProgress) {
      let totalBet = 0;
      let totalWin = 0;
      const chunk = 2000;
      for (let i = 0; i < spins; i += chunk) {
        const end = Math.min(spins, i + chunk);
        for (let j = i; j < end; j++) {
          const baseResult = resolveSpinSimulation(betPerLineForSim, linesForSim, false, 1);
          totalWin += baseResult.win;
          totalBet += betPerLineForSim * linesForSim;

          if (baseResult.freeSpinsAwarded > 0) {
            let bonusGlobal = 1;
            let pendingFs = Math.min(100, baseResult.freeSpinsAwarded);
            while (pendingFs > 0) {
              pendingFs--;
              const bonusResult = resolveSpinSimulation(betPerLineForSim, linesForSim, true, bonusGlobal);
              bonusGlobal = bonusResult.globalSim;
              totalWin += bonusResult.win;
              if (bonusResult.retriggerSpins > 0) {
                pendingFs = Math.min(100, pendingFs + bonusResult.retriggerSpins);
              }
            }
          }
        }
        if (onProgress) onProgress(Math.min(1, (end) / spins));
        // yield to UI
        await new Promise((r) => setTimeout(r, 0));
      }
      return { totalBet, totalWin, rtp: totalWin / totalBet };
    }

    // ---- EVENTI ---------------------------------------------------------

    if (betMinusBtn) {
      betMinusBtn.addEventListener("click", () => {
        if (inFreeSpins) {
          setMessage(
            "Non puoi cambiare la puntata durante i free spin.",
            "error"
          );
          return;
        }
        if (betPerLine > MIN_BET_PER_LINE) {
          betPerLine = Math.max(MIN_BET_PER_LINE, parseFloat((betPerLine - BET_STEP).toFixed(2)));
          updateBetDisplay();
          saveState();
        }
      });
    }

    if (betPlusBtn) {
      betPlusBtn.addEventListener("click", () => {
        if (inFreeSpins) {
          setMessage(
            "Non puoi cambiare la puntata durante i free spin.",
            "error"
          );
          return;
        }
        if (betPerLine < MAX_BET_PER_LINE) {
          betPerLine = Math.min(MAX_BET_PER_LINE, parseFloat((betPerLine + BET_STEP).toFixed(2)));
          updateBetDisplay();
          saveState();
        }
      });
    }

    // Pay-anywhere: nessuna linea modificabile.
    if (linesMinusBtn) {
      linesMinusBtn.addEventListener("click", () => {
        setMessage("Schema pay-anywhere: nessuna linea da modificare.", "error");
      });
    }
    if (linesPlusBtn) {
      linesPlusBtn.addEventListener("click", () => {
        setMessage("Schema pay-anywhere: nessuna linea da modificare.", "error");
      });
    }

    if (autoMinusBtn) {
      autoMinusBtn.addEventListener("click", () => {
        if (autoSpinCount > MIN_AUTO) {
          autoSpinCount -= AUTO_STEP;
          updateAutoCountDisplay();
          saveState();
        }
      });
    }
    if (autoPlusBtn) {
      autoPlusBtn.addEventListener("click", () => {
        if (autoSpinCount < MAX_AUTO) {
          autoSpinCount += AUTO_STEP;
          updateAutoCountDisplay();
          saveState();
        }
      });
    }

    if (spinBtn) {
      spinBtn.addEventListener("click", () => {
        autoSpinsLeft = 0;
        updateAutoLabel();
        spinOnce(false);
      });
    }

    if (autoBtn) {
      autoBtn.addEventListener("click", () => {
        if (inFreeSpins) {
          setMessage(
            "Non puoi avviare l'auto-spin durante i free spin.",
            "error"
          );
          return;
        }
        if (autoSpinsLeft > 0) {
          autoSpinsLeft = 0;
          updateAutoLabel();
          setMessage("Auto-spin fermato.");
        } else {
          autoSpinsLeft = autoSpinCount;
          updateAutoLabel();
          spinOnce(true);
        }
      });
    }

    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
      credits = 1000;
      betPerLine = 1.0;
      activeLines = TOTAL_LINES;
      autoSpinCount = 10;
      autoSpinsLeft = 0;
      lastWin = 0;
      inFreeSpins = false;
      freeSpins = 0;
      bonusBetPerLine = 1;
      bonusLines = TOTAL_LINES;
      clearWins();
      updateCredits();
      updateBetDisplay();
      updateLinesDisplay();
      updateLastWin();
      updateAutoCountDisplay();
      updateMode();
      updateAutoLabel();
      saveState();
      setMessage("Crediti, linee e puntata resettati.");
      });
    }

    // play-bar controls
    if (betTotalMinusBtn && betTotalPlusBtn && betTotalDisplay) {
      const stepTotal = 0.01; // adjust total bet in euros (cents)
      betTotalMinusBtn.addEventListener('click', () => {
        const total = Math.max(0, parseFloat(((betPerLine * activeLines) - stepTotal).toFixed(2)));
        betPerLine = Math.max(MIN_BET_PER_LINE, parseFloat((total / activeLines).toFixed(2)));
        updateBetDisplay();
        saveState();
      });
      betTotalPlusBtn.addEventListener('click', () => {
        const total = parseFloat(((betPerLine * activeLines) + stepTotal).toFixed(2));
        betPerLine = Math.min(MAX_BET_PER_LINE, parseFloat((total / activeLines).toFixed(2)));
        updateBetDisplay();
        saveState();
      });
    }

    if (turboBtn) {
      function updateTurboUI() {
        if (turboMode) {
          turboBtn.classList.add('active');
            turboBtn.setAttribute('aria-pressed', 'true');
        } else {
          turboBtn.classList.remove('active');
          turboBtn.setAttribute('aria-pressed', 'false');
        }
      }
      turboBtn.addEventListener('click', () => {
        turboMode = !turboMode;
        updateTurboUI();
        saveState();
      });
      updateTurboUI();
    }

    if (autoToggleBtn) {
      autoToggleBtn.addEventListener('click', () => {
        if (autoSpinsLeft > 0) {
          autoSpinsLeft = 0;
          autoToggleBtn.setAttribute('aria-pressed', 'false');
          setMessage('Auto-spin fermato.');
        } else {
          autoSpinsLeft = autoSpinCount;
          autoToggleBtn.setAttribute('aria-pressed', 'true');
          setMessage(`Auto-spin avviato (${autoSpinsLeft})`);
          spinOnce(true);
        }
        updateAutoLabel();
      });
    }

    if (playSmallBtn) {
      playSmallBtn.addEventListener('click', () => {
        spinOnce(false);
      });
    }

    // (Keyboard shortcuts removed per user request)

    // RTP button
    const rtpBtn = document.getElementById('rtpBtn');
    const rtpCountEl = document.getElementById('rtp-count');
    const rtpResultEl = document.getElementById('rtpResult');
    if (rtpBtn && rtpCountEl && rtpResultEl) {
      rtpBtn.addEventListener('click', async () => {
        const n = Math.max(1000, Number(rtpCountEl.value) || 100000);
        rtpResultEl.textContent = 'Calcolo in corso...';
        rtpBtn.disabled = true;
        const start = performance.now();
        const result = await estimateRTP(n, betPerLine, activeLines, (p) => {
          rtpResultEl.textContent = `Calcolo: ${Math.round(p*100)}%`;
        });
        const took = ((performance.now() - start) / 1000).toFixed(1);
        const rtpPct = (result.rtp * 100).toFixed(3);
        rtpResultEl.textContent = `RTP: ${rtpPct}% (spins: ${n}) â€” tempo: ${took}s`;
        rtpBtn.disabled = false;
      });
    }

    // ---- INIT -----------------------------------------------------------

    loadState();
    updateCredits();
    updateBetDisplay();
    updateLinesDisplay();
    updateLastWin();
    updateAutoCountDisplay();
    updateMode();
    updateAutoLabel();
    setMessage(
      "Slot 6Ã—5 pay-anywhere con tumble, scatter per i free spin e moltiplicatori casuali. Premi SPIN!"
    );

    // assicurati che play-bar mostri i valori corretti
    if (displayCreditsEl) displayCreditsEl.textContent = formatCurrency(credits);
    if (betTotalDisplay) betTotalDisplay.textContent = formatCurrency(betPerLine * activeLines);
  </script>
</body>
</html>
