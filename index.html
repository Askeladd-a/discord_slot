<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discord Slot â€“ 10 Linee Wild / Scatter / Multi</title>
  <style>
    :root {
      --cell-size: min(14vw, 110px);
      --bg: #050608;
      --card-bg: #1f2027;
      --card-border: #2a2b33;
      --accent: #6c63ff;
      --accent-soft: #8b83ff;
      --text-main: #f4f6fb;
      --text-muted: #b0b3bd;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      background: radial-gradient(circle at top, #151824, #050608 60%);
      color: var(--text-main);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      padding: 24px 12px;
    }

    h1 {
      margin-bottom: 0.2rem;
      text-align: center;
      font-size: clamp(1.6rem, 4vw, 2.1rem);
      text-shadow: 0 0 18px rgba(0, 0, 0, 0.7);
    }

    p.subtitle {
      margin-top: 0;
      margin-bottom: 0.9rem;
      font-size: 0.9rem;
      opacity: 0.9;
      text-align: center;
      color: var(--text-muted);
    }

    .slot-wrapper {
      background: radial-gradient(circle at top, #292b3a, #181924 60%);
      border-radius: 22px;
      padding: 18px;
      border: 1px solid var(--card-border);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.75),
        0 0 0 1px rgba(255, 255, 255, 0.02);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 14px;
      max-width: 1000px;
    }

    .slot-frame {
      position: relative;
      display: inline-block;
    }

    .slot-container {
      display: grid;
      grid-template-columns: repeat(6, var(--cell-size));
      grid-template-rows: repeat(5, var(--cell-size));
      gap: 10px;
      padding: 14px;
      background: linear-gradient(180deg,#0f1116,#0b0c11);
      border-radius: 18px;
      box-shadow: inset 0 6px 18px rgba(0, 0, 0, 0.7);
      justify-content: center;
      position: relative;
      z-index: 1;
    }

    .slot-cell {
      width: var(--cell-size);
      height: var(--cell-size);
      background: linear-gradient(180deg,#0a0b0f,#07080b);
      border-radius: 14px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.65);
    }

    .slot-cell img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transition:
        transform 0.18s ease,
        box-shadow 0.18s ease,
        outline 0.18s ease,
        filter 0.18s ease;
    }

    .slot-cell img.win {
      transform: scale(1.06);
      outline: 3px solid var(--win-color, #ffd700);
      box-shadow:
        0 0 16px rgba(0, 0, 0, 0.8),
        0 0 18px var(--win-color, #ffd700);
      filter: saturate(1.25);
    }

    .paylines-svg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
      overflow: visible;
    }

    .info-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px 18px;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .info-block {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .info-label {
      opacity: 0.8;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      justify-content: center;
      gap: 10px;
      margin-top: 4px;
    }

    /* play bar (compact controls sotto la slot) */
    .play-bar {
      width: 100%;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-top: 10px;
      padding: 14px 16px;
      background: linear-gradient(180deg, rgba(255,255,255,0.02), transparent);
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,0.03);
    }

    .controls-play { display:flex; gap:10px; align-items:center; }
    .toggles { display:flex; gap:12px; align-items:center }
    .play-area .bet { margin-right:12px; }
    .controls.compact { display:none; }

    .bottom-row {
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      margin-top:10px;
    }
    .sim-controls { display:flex; gap:8px; align-items:center; }
    .input-short { width:110px; padding:6px; border-radius:6px; border:1px solid rgba(255,255,255,0.04); background:#0e0f13; color:var(--text-main); }
    .rtp-result { color:var(--text-muted); min-width:220px; text-align:center; }
    .rtp-result strong { color: var(--accent); font-weight:800; }
    .status-compact { color:var(--text-muted); display:flex; gap:8px; align-items:center; }
    .value-compact { font-weight:700; color:var(--text-main); }

    .play-area {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .play-area .step {
      padding: 0.2rem 0.6rem;
      font-size: 0.95rem;
    }

    .currency {
      font-weight: 700;
      min-width: 86px;
      text-align: center;
    }

    .toggle {
      display: inline-flex;
      gap: 8px;
      align-items: center;
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .toggle button {
      padding: 0.25rem 0.6rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #2b2d38;
      color: #fff;
      font-weight: 600;
    }

    .toggle button.active {
      background: var(--accent);
      box-shadow: 0 6px 14px rgba(88,101,242,0.28);
    }

    .play-btn {
      padding: 0.6rem 1.1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: 800;
      background: linear-gradient(180deg,var(--accent),var(--accent-soft));
      color: white;
      box-shadow: 0 14px 30px rgba(108,99,255,0.18);
      letter-spacing: .4px;
    }

    /* improved control buttons */
    .btn-primary, .btn-secondary, .step {
      border: none;
      background: #2b2d38;
      color: var(--text-main);
      padding: 0.5rem 0.7rem;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 700;
      transition: transform .08s ease, box-shadow .12s ease, background .12s ease;
    }

    .btn-primary {
      background: linear-gradient(180deg,var(--accent),var(--accent-soft));
      box-shadow: 0 14px 28px rgba(108,99,255,0.16);
      color: white;
      padding: 0.65rem 0.95rem;
      border-radius: 14px;
      font-weight:800;
    }

    .btn-secondary {
      background: linear-gradient(180deg,#33343c,#2b2d38);
      color: var(--text-main);
      padding: 0.5rem 0.85rem;
    }

    .step:hover, .btn-secondary:hover, .btn-primary:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,0,0,0.6);
    }

    .step:active, .btn-secondary:active, .btn-primary:active {
      transform: translateY(0px) scale(.995);
    }

    .step[disabled] { opacity: 0.5; cursor: not-allowed; }

    /* tooltips removed per user request */

    /* focus styles for accessibility */
    .btn-primary:focus, .btn-secondary:focus, .step:focus {
      outline: 3px solid rgba(88,101,242,0.22);
      outline-offset: 3px;
    }

    .bet {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      flex-wrap: wrap;
      justify-content: center;
      font-size: 0.9rem;
    }

    .bet button.step {
      padding: 0.1rem 0.55rem;
      font-size: 0.9rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      background: #323347;
      color: #fff;
      font-weight: 600;
    }

    .bet span.value {
      min-width: 2.4rem;
      text-align: center;
      display: inline-block;
      font-variant-numeric: tabular-nums;
    }

    .btn-primary,
    .btn-secondary {
      padding: 0.5rem 1.4rem;
      font-size: 1rem;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      transition:
        background 0.15s ease,
        transform 0.1s ease,
        box-shadow 0.15s ease;
    }

    .btn-primary {
      background: var(--accent);
      color: #fff;
      box-shadow: 0 8px 18px rgba(88, 101, 242, 0.45);
    }

    .btn-primary:hover:not(:disabled) {
      background: var(--accent-soft);
      transform: translateY(-1px);
      box-shadow: 0 10px 22px rgba(88, 101, 242, 0.6);
    }

    .btn-secondary {
      background: #333548;
      color: #e5e7ff;
    }

    .btn-secondary:hover:not(:disabled) {
      background: #3c3f58;
      transform: translateY(-1px);
    }

    button:disabled {
      background: #3a3a47 !important;
      cursor: not-allowed;
      box-shadow: none !important;
      transform: none !important;
    }

    .message {
      min-height: 1.4rem;
      max-width: 620px;
      text-align: center;
      font-size: 0.9rem;
      margin-top: 6px;
      color: var(--text-muted);
      background: linear-gradient(180deg, rgba(255,255,255,0.01), rgba(0,0,0,0.02));
      padding: 8px 12px;
      border-radius: 8px;
    }

    .message--win {
      color: #b8ffb2;
    }

    .message--nice {
      color: #ffe66d;
    }

    .message--bigwin {
      color: #ffd166;
      font-weight: 600;
      font-size: 1rem;
    }

    .message--error {
      color: #ff7b7b;
    }

    .message--bonus {
      color: #ffdd6f;
    }

    @media (max-width: 600px) {
      .slot-wrapper {
        padding: 14px;
      }

      .slot-container {
        padding: 8px;
        gap: 6px;
      }

      .btn-primary,
      .btn-secondary {
        padding: 0.45rem 1.1rem;
        font-size: 0.9rem;
      }
    }
  </style>
</head>
<body>
  <h1>Discord Slot â€“ Ispirata a Gates Of Olympus (6Ã—5 Pay-Anywhere)</h1>
  <p class="subtitle">
    Griglia 6Ã—5 pay-anywhere: conta simboli su tutto il pannello, scatter/free spin e moltiplicatori âš¡
  </p>

  <div class="slot-wrapper">
    <div class="slot-frame">
      <div class="slot-container">
        <!-- 5 righe x 6 colonne = 30 slot (0â€“29) -->
        <div class="slot-cell"><img id="slot-0" src="img/user1.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-1" src="img/user2.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-2" src="img/user3.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-3" src="img/user4.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-4" src="img/user5.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-5" src="img/user6.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-6" src="img/user7.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-7" src="img/user8.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-8" src="img/user9.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-9" src="img/user10.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-10" src="img/user1.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-11" src="img/user2.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-12" src="img/user3.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-13" src="img/user4.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-14" src="img/user5.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-15" src="img/user6.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-16" src="img/user7.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-17" src="img/user8.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-18" src="img/user9.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-19" src="img/user10.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-20" src="img/user1.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-21" src="img/user2.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-22" src="img/user3.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-23" src="img/user4.png" alt="" /></div>

        <div class="slot-cell"><img id="slot-24" src="img/user5.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-25" src="img/user6.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-26" src="img/user7.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-27" src="img/user8.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-28" src="img/user9.png" alt="" /></div>
        <div class="slot-cell"><img id="slot-29" src="img/user10.png" alt="" /></div>
      </div>
      <svg id="paylinesSvg" class="paylines-svg"></svg>
    </div>

    <div class="info-row">
      <div class="info-block">
        <span class="info-label">Crediti:</span>
        <span id="credits">1000</span>
      </div>
      <div class="info-block">
        <span class="info-label">ModalitÃ :</span>
        <span id="mode">Base</span>
        <span class="info-label">| Free spin:</span>
        <span id="fs-count">0</span>
      </div>
      <div class="info-block">
        <span class="info-label">Ultima vincita:</span>
        <span id="last-win">0</span>
      </div>
      <div class="info-block">
        <span class="info-label">Linee attive:</span>
        <span id="info-lines">25</span>
      </div>
    </div>

    <!-- compact controls removed to declutter; main actions moved into play-bar for clarity -->

    <div class="play-bar" id="playBar">
      <div class="play-area">
        <div class="currency">â‚¬ <span id="display-credits">0.00</span></div>
        <div class="bet">Puntata/linea: <button class="step" id="bet-minus">âˆ’</button> <span id="bet-per-line" class="value">1.00</span> <button class="step" id="bet-plus">+</button></div>
        <div class="bet">Linee: <span id="lines-count" class="value">25</span></div>
        <div class="bet">Totale: <span id="total-bet" class="value">25.00</span></div>
      </div>

      <div class="controls-play">
        <button class="btn-primary" id="spinBtn">SPIN</button>
        <button class="btn-secondary" id="autoBtn">AUTO</button>
        <button class="btn-secondary" id="resetBtn">RESET</button>
      </div>

      <div class="toggles">
        <div class="toggle"><label for="turboBtn">TURBO</label><button id="turboBtn" aria-pressed="false" aria-label="Toggle turbo">T</button></div>
        <div class="toggle"><label for="autoToggle">AUTOMATICO</label><button id="autoToggle" aria-pressed="false" aria-label="Toggle auto">A</button></div>
      </div>
    </div>

    <div class="bottom-row">
      <div class="sim-controls">
        <label class="info-label" for="rtp-count">Simulazioni</label>
        <input id="rtp-count" type="number" value="100000" min="1000" step="1000" class="input-short" />
        <button id="rtpBtn" class="step">Calcola RTP</button>
        <div id="rtpResult" class="rtp-result">RTP: â€”</div>
      </div>

      <div class="status-compact">
        <span class="info-label">Crediti:</span>
        <span id="creditsCompact" class="value-compact">0.00</span>
        <span class="sep">â€¢</span>
        <span class="info-label">ModalitÃ :</span>
        <span id="modeCompact" class="value-compact">Base</span>
      </div>
    </div>

    <div class="message" id="message"></div>
  </div>

  <script>
    // ---- CONFIG ---------------------------------------------------------

    const members = [
      { name: "User1", img: "img/user1.png" },
      { name: "User2", img: "img/user2.png" },
      { name: "User3", img: "img/user3.png" },
      { name: "User4", img: "img/user4.png" },
      { name: "User5", img: "img/user5.png" },
      { name: "User6", img: "img/user6.png" },
      { name: "User7", img: "img/user7.png" },
      { name: "User8", img: "img/user8.png" },
      { name: "User9", img: "img/user9.png" },
      { name: "User10", img: "img/user10.png" },
      { name: "User11", img: "img/user11.png" },
      { name: "User12", img: "img/user12.png" }
    ];

    const SCATTER = {
      name: "SCATTER",
      img: "img/scatter.png",
      isScatter: true
    };

    const WILD = {
      name: "WILD",
      img: "img/wild.png",
      isWild: true
    };

    const MULT = {
      name: "MULT",
      img: "img/multi.png",
      isMultiplier: true
    };

    const ROWS = 5;
    const COLS = 6;
    const TOTAL_SLOTS = ROWS * COLS;

    // for Gates-like behaviour we use pay-anywhere: counts across the whole panel
    const PAY_ANYWHERE = true;
    const TOTAL_LINES = 0; // legacy UI value (not used when PAY_ANYWHERE=true)

    // per-symbol payouts for 3/4/5 matches (values in currency relative to betPerLine)
    // scaled symbol payouts (tuning applied Ã—5)
    const SYMBOL_PAYOUTS = {
      // user1..user10 -> payouts for 3,4,5 (per-line amounts)
      User1: {3:4.00*5, 4:8.00*5, 5:50.00*5},
      User2: {3:1.20*5,4:3.00*5,5:10.00*5},
      User3: {3:1.20*5,4:3.00*5,5:10.00*5},
      User4: {3:0.80*5,4:1.50*5,5:6.00*5},
      User5: {3:0.80*5,4:1.50*5,5:6.00*5},
      User6: {3:0.50*5,4:0.80*5,5:3.00*5},
      User7: {3:0.50*5,4:0.80*5,5:3.00*5},
      User8: {3:0.50*5,4:0.80*5,5:3.00*5},
      User9: {3:0.50*5,4:0.80*5,5:3.00*5},
        User10:{3:0.50*5,4:0.80*5,5:3.00*5},
        User11:{3:0.40*5,4:0.70*5,5:2.50*5},
        User12:{3:0.40*5,4:0.70*5,5:2.50*5}
    };

    // scatter paga sulla puntata totale
    // scaled payouts (tuning): scale x5
    const SCATTER_PAYOUT = {
      3: 5 * 5,
      4: 15 * 5,
      5: 30 * 5
    };

    // multipliers for 'of a kind' used in UI messages (3/4/5 of a kind)
    const OF_A_KIND_MULT = { 3: 2, 4: 5, 5: 10 };

    const FREE_SPIN_TRIGGER = 3;
    // free spin awards based on scatter count (attachment reference)
    const FREE_SPIN_AWARDS = {
      3: 10,
      4: 20,
      5: 50
    };
    const FREE_SPIN_MULTIPLIER = 2; // tutte le win x2 nei free spin
    // multiplier symbol value: each MULT symbol multiplies wins by MULT_VALUE (stacked as power)
    const MULT_VALUE = 2;

    // distribuzione simboli (scatter / wild / multiplier piÃ¹ rari)
    const WEIGHTED_SYMBOLS = [];
    // member weight kept at 5. Scatter 1. Wild and Mult increased per tuning.
    members.forEach((m) => {
      WEIGHTED_SYMBOLS.push({ symbol: m, weight: 5 });
    });
    WEIGHTED_SYMBOLS.push({ symbol: SCATTER, weight: 1 });
    WEIGHTED_SYMBOLS.push({ symbol: WILD, weight: 6 });
    WEIGHTED_SYMBOLS.push({ symbol: MULT, weight: 4 });

    const TOTAL_WEIGHT = WEIGHTED_SYMBOLS.reduce(
      (sum, e) => sum + e.weight,
      0
    );

    const LINE_COLORS = [
      "#ffb703",
      "#4cc9f0",
      "#ff595e",
      "#b8ff5c",
      "#f72585",
      "#ffd166",
      "#06d6a0",
      "#a0c4ff",
      "#ffadad",
      "#c77dff"
    ];

    const STORAGE_KEY = "discord_slot_10lines_wsm_v1";
    let turboMode = false;

    // ---- STATO ----------------------------------------------------------

    let credits = 1000.0;
    let betPerLine = 1.0;
    const MIN_BET_PER_LINE = 0.01; // allow betting cents
    const BET_STEP = 0.01;
    const MAX_BET_PER_LINE = 100;

    let activeLines = TOTAL_LINES;
    const MIN_LINES = 1;
    const MAX_LINES = TOTAL_LINES;

    let autoSpinCount = 10;
    const MIN_AUTO = 10;
    const MAX_AUTO = 100;
    const AUTO_STEP = 10;

    let autoSpinsLeft = 0;
    let lastWin = 0;

    let inFreeSpins = false;
    let freeSpins = 0;
    let bonusBetPerLine = 1;
    let bonusLines = TOTAL_LINES;

    // ---- DOM ------------------------------------------------------------

    const creditsEl = document.getElementById("credits");
    const modeEl = document.getElementById("mode");
    const fsCountEl = document.getElementById("fs-count");
    const lastWinEl = document.getElementById("last-win");
    const infoLinesEl = document.getElementById("info-lines");

    const messageEl = document.getElementById("message");
    const spinBtn = document.getElementById("spinBtn");
    const autoBtn = document.getElementById("autoBtn");
    const resetBtn = document.getElementById("resetBtn");

    const betMinusBtn = document.getElementById("bet-minus");
    const betPlusBtn = document.getElementById("bet-plus");
    const betPerLineEl = document.getElementById("bet-per-line");
    const totalBetEl = document.getElementById("total-bet");

    const linesMinusBtn = document.getElementById("lines-minus");
    const linesPlusBtn = document.getElementById("lines-plus");
    const linesCountEl = document.getElementById("lines-count");

    const autoMinusBtn = document.getElementById("auto-minus");
    const autoPlusBtn = document.getElementById("auto-plus");
    const autoCountEl = document.getElementById("auto-count");

    const slotContainer = document.querySelector(".slot-container");
    const paylinesSvg = document.getElementById("paylinesSvg");
    const displayCreditsEl = document.getElementById("display-credits");
    const betTotalMinusBtn = document.getElementById("bet-total-minus");
    const betTotalPlusBtn = document.getElementById("bet-total-plus");
    const betTotalDisplay = document.getElementById("bet-total-display");
    const turboBtn = document.getElementById("turboBtn");
    const autoToggleBtn = document.getElementById("autoToggle");
    const playSmallBtn = document.getElementById("playSmall");

    // ---- UTIL -----------------------------------------------------------

    function saveState() {
      try {
        const state = {
          credits,
          betPerLine,
          activeLines,
          autoSpinCount,
          turboMode
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch {}
    }

    function loadState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return;
        const state = JSON.parse(raw);
        if (typeof state.credits === "number") credits = state.credits;
        if (typeof state.betPerLine === "number") {
          betPerLine = Math.min(
            MAX_BET_PER_LINE,
            Math.max(MIN_BET_PER_LINE, state.betPerLine)
          );
        }
        if (typeof state.activeLines === "number") {
          activeLines = Math.min(
            MAX_LINES,
            Math.max(MIN_LINES, state.activeLines)
          );
        }
        if (typeof state.autoSpinCount === "number") {
          autoSpinCount = Math.min(
            MAX_AUTO,
            Math.max(MIN_AUTO, state.autoSpinCount)
          );
        }
        if (typeof state.turboMode === "boolean") {
          turboMode = state.turboMode;
        }
      } catch {}
    }

    function getCurrentBetPerLine() {
      return inFreeSpins ? bonusBetPerLine : betPerLine;
    }

    function getCurrentLines() {
      return inFreeSpins ? bonusLines : activeLines;
    }

    function formatCurrency(n) {
      return Number(n).toFixed(2);
    }

    function updateCredits() {
      creditsEl.textContent = formatCurrency(credits);
      if (displayCreditsEl) displayCreditsEl.textContent = formatCurrency(credits);
      const creditsCompact = document.getElementById('creditsCompact');
      if (creditsCompact) creditsCompact.textContent = formatCurrency(credits);
    }

    function updateMode() {
      modeEl.textContent = inFreeSpins ? "Bonus (Free Spin)" : "Base";
      fsCountEl.textContent = freeSpins;
      const modeCompact = document.getElementById('modeCompact');
      if (modeCompact) modeCompact.textContent = inFreeSpins ? "Bonus" : "Base";
    }

    function updateLastWin() {
      lastWinEl.textContent = formatCurrency(lastWin);
    }

    function updateBetDisplay() {
      betPerLineEl.textContent = formatCurrency(betPerLine);
      totalBetEl.textContent = formatCurrency(betPerLine * activeLines);
      if (betTotalDisplay) betTotalDisplay.textContent = formatCurrency(betPerLine * activeLines);
    }

    function updateLinesDisplay() {
      linesCountEl.textContent = activeLines;
      infoLinesEl.textContent = activeLines;
      totalBetEl.textContent = formatCurrency(betPerLine * activeLines);
      if (betTotalDisplay) betTotalDisplay.textContent = formatCurrency(betPerLine * activeLines);
    }

    function updateAutoCountDisplay() {
      autoCountEl.textContent = autoSpinCount;
    }

    function updateAutoLabel() {
      autoBtn.textContent =
        autoSpinsLeft > 0 ? `AUTO (${autoSpinsLeft})` : "AUTO";
    }

    function setMessage(text, type = "normal") {
      messageEl.textContent = text;
      messageEl.className = "message";
      if (type && type !== "normal") {
        messageEl.classList.add(`message--${type}`);
      }
    }

    function randomSymbol(slotIndex = 0) {
      // choose symbol respecting reel-specific restrictions (wild only on reels 2..4 -> indexes 1..3)
      const col = slotIndex % COLS;
      let total = 0;
      for (const entry of WEIGHTED_SYMBOLS) {
        // if entry is WILD and column is first or last, skip by treating weight 0
        const w = entry.symbol.isWild && (col === 0 || col === COLS - 1) ? 0 : entry.weight;
        total += w;
      }
      let r = Math.random() * total;
      for (const entry of WEIGHTED_SYMBOLS) {
        const w = entry.symbol.isWild && (col === 0 || col === COLS - 1) ? 0 : entry.weight;
        if (r < w) return entry.symbol;
        r -= w;
      }
      // fallback
      return WEIGHTED_SYMBOLS[0].symbol;
    }

    function setSlotImage(slotIndex, symbol) {
      const img = document.getElementById(`slot-${slotIndex}`);
      img.src = symbol.img;
      img.alt = symbol.name;
    }

    function clearPaylines() {
      if (paylinesSvg) {
        paylinesSvg.innerHTML = "";
      }
    }

    function clearWins() {
      const imgs = document.querySelectorAll(".slot-cell img");
      imgs.forEach((img) => {
        img.classList.remove("win");
        img.style.removeProperty("--win-color");
      });
      clearPaylines();
    }

    function markIndices(indices, color) {
      indices.forEach((index) => {
        const img = document.getElementById(`slot-${index}`);
        img.classList.add("win");
        if (color) {
          img.style.setProperty("--win-color", color);
        }
      });
    }

    function getSlotCenter(index) {
      const img = document.getElementById(`slot-${index}`);
      const imgRect = img.getBoundingClientRect();
      const contRect = slotContainer.getBoundingClientRect();
      return {
        x: imgRect.left - contRect.left + imgRect.width / 2,
        y: imgRect.top - contRect.top + imgRect.height / 2
      };
    }

    function drawPaylines(lines) {
      clearPaylines();
      if (!lines.length) return;

      const width = slotContainer.clientWidth;
      const svgNS = "http://www.w3.org/2000/svg";

      paylinesSvg.setAttribute("width", width);
      paylinesSvg.setAttribute("height", slotContainer.clientHeight);
      paylinesSvg.setAttribute(
        "viewBox",
        `0 0 ${slotContainer.clientWidth} ${slotContainer.clientHeight}`
      );

      lines.forEach((line) => {
        const poly = document.createElementNS(svgNS, "polyline");
        const points = line.lineSlots
          .map((i) => {
            const c = getSlotCenter(i);
            return `${c.x},${c.y}`;
          })
          .join(" ");
        poly.setAttribute("points", points);
        poly.setAttribute("stroke", line.color || "#ffd700");
        poly.setAttribute("stroke-width", "4");
        poly.setAttribute("fill", "none");
        poly.setAttribute("stroke-linecap", "round");
        poly.setAttribute("stroke-linejoin", "round");
        poly.setAttribute("stroke-dasharray", "9 6");
        paylinesSvg.appendChild(poly);
      });
    }

    // animazione rulli
    function spinAnimation(finalSymbols, onComplete) {
      const columns = [];
      for (let c = 0; c < COLS; c++) {
        const colIndices = [];
        for (let r = 0; r < ROWS; r++) {
          colIndices.push(r * COLS + c);
        }
        columns.push(colIndices);
      }
      let finishedColumns = 0;
      const steps = turboMode ? 3 : 4;
      const stepDuration = turboMode ? 70 : 120;

      columns.forEach((indices, colIndex) => {
        const startDelay = colIndex * (turboMode ? 80 : 140);
        setTimeout(() => {
          let step = 0;
          const interval = setInterval(() => {
            indices.forEach((i) => setSlotImage(i, randomSymbol()));
            step++;
            if (step >= steps) {
              clearInterval(interval);
              indices.forEach((i) => setSlotImage(i, finalSymbols[i]));
              finishedColumns++;
              if (finishedColumns === columns.length) {
                onComplete();
              }
            }
          }, stepDuration);
        }, startDelay);
      });
    }

    // ---- LOGICA DI GIOCO -----------------------------------------------

    function spinOnce(fromAuto = false) {
      if (inFreeSpins && freeSpins <= 0) {
        inFreeSpins = false;
        updateMode();
      }

      const wasFreeSpin = inFreeSpins;

      if (fromAuto && !wasFreeSpin) {
        if (autoSpinsLeft <= 0) {
          updateAutoLabel();
          return;
        }
        autoSpinsLeft--;
        updateAutoLabel();
      }

      const currentBetPerLine = getCurrentBetPerLine();
      const currentLines = getCurrentLines();
      let betTotal = 0;

      if (!wasFreeSpin) {
        betTotal = currentBetPerLine * currentLines;
        if (credits < betTotal) {
          setMessage("Non hai abbastanza crediti per questa puntata.", "error");
          autoSpinsLeft = 0;
          updateAutoLabel();
          return;
        }
        credits -= betTotal;
        updateCredits();
        saveState();
      } else {
        if (freeSpins > 0) {
          freeSpins--;
        }
      }

      updateMode();
      setMessage("");
      clearWins();

      spinBtn.disabled = true;
      autoBtn.disabled = true;

      const finalSymbols = [];
      for (let i = 0; i < TOTAL_SLOTS; i++) {
        finalSymbols.push(randomSymbol(i));
      }

      spinAnimation(finalSymbols, () => {
        try {
          evaluateResult(
            finalSymbols,
            betTotal,
            currentBetPerLine,
            currentLines,
            wasFreeSpin
          );
        } catch (err) {
          console.error("Error in evaluateResult:", err);
          setMessage("Errore interno durante la risoluzione del giro. Riprova.", "error");
        } finally {
          // ensure UI is always re-enabled so user can continue
          try {
            if (spinBtn) spinBtn.disabled = false;
            if (autoBtn) autoBtn.disabled = false;
          } catch (e) {
            console.error("Error re-enabling buttons:", e);
          }
        }

        if (autoSpinsLeft > 0 && !inFreeSpins) {
          const nextBet = betPerLine * activeLines;
          if (credits >= nextBet) {
            setTimeout(() => spinOnce(true), 450);
          } else {
            autoSpinsLeft = 0;
            updateAutoLabel();
            setMessage(
              "Auto-spin fermato: crediti insufficienti.",
              "error"
            );
          }
        }
      });
    }

    function evaluateResult(
      resultSymbols,
      betTotal,
      currentBetPerLine,
      currentLines,
      wasFreeSpin
    ) {
      // pay-anywhere: count occurrences of each symbol across panel
      let wildMultiplierSum = 0;
      resultSymbols.forEach((s) => {
        if (s.isWild) wildMultiplierSum += 1 + Math.floor(Math.random() * 3);
      });
      const wildMultiplier = wildMultiplierSum > 0 ? wildMultiplierSum : 1;

      let totalWinBase = 0;
      lastWin = 0;
      const wins = [];
      const baseTotalBet = currentBetPerLine * currentLines;

      // scatter
      let scatterCount = 0;
      const scatterIndices = [];
      resultSymbols.forEach((sym, idx) => {
        if (sym.isScatter) {
          scatterCount++;
          scatterIndices.push(idx);
        }
      });

      // count regular symbols (members and wild)
      // collect natural indices per symbol and wild indices
      const counts = new Map();
      const wildIndices = [];
      resultSymbols.forEach((sym, idx) => {
        if (sym.isScatter || sym.isMultiplier) return;
        if (sym.isWild) {
          wildIndices.push(idx);
          return;
        }
        if (!counts.has(sym.name)) counts.set(sym.name, { count: 0, indices: [] });
        const ent = counts.get(sym.name);
        ent.count++;
        ent.indices.push(idx);
      });

      // evaluate payouts for each symbol type, allowing wilds to contribute as jokers
      counts.forEach((info, key) => {
        const natural = info.count;
        const effective = natural + wildIndices.length;
        if (effective < 3) return;
        const payoutKey = effective >= 5 ? 5 : effective;
        let basePayout = (SYMBOL_PAYOUTS[key] && SYMBOL_PAYOUTS[key][payoutKey]) || 0;
        if (basePayout > 0) {
          const multCount = resultSymbols.filter(s => s.isMultiplier).length;
          const symbolMultiplier = multCount > 0 ? Math.pow(MULT_VALUE, multCount) : 1;
          const winAmount = basePayout * symbolMultiplier * currentBetPerLine;
          totalWinBase += winAmount;
          // choose indices: natural ones first, then some wild indices if needed
          const neededFromWild = Math.max(0, payoutKey - natural);
          const usedWild = wildIndices.slice(0, neededFromWild);
          const winIndices = [...info.indices.slice(0, payoutKey), ...usedWild].slice(0, payoutKey);
          wins.push({ symbol: key, count: payoutKey, winAmount, indices: winIndices });
        }
      });

      // scatter payout + bonus
      let scatterWinBase = 0;
      let bonusText = '';
      if (scatterCount >= FREE_SPIN_TRIGGER) {
        const key = scatterCount >= 5 ? 5 : scatterCount;
        const scatterMult = SCATTER_PAYOUT[key] || 0;
        if (scatterMult > 0) {
          scatterWinBase = scatterMult * baseTotalBet;
          totalWinBase += scatterWinBase;
        }
        const awarded = FREE_SPIN_AWARDS[key] || 0;
        freeSpins = Math.min(50, freeSpins + awarded);
        inFreeSpins = true;
        bonusBetPerLine = currentBetPerLine;
        bonusLines = currentLines;
        autoSpinsLeft = 0;
        updateAutoLabel();
        bonusText = `Bonus! ${scatterCount} scatter: ${scatterMult}Ã— puntata totale (+${scatterWinBase}) e +${awarded} free spin ðŸŽ`;
      }

      // free spin multiplier
      let totalWin = totalWinBase;
      if (wasFreeSpin && totalWinBase > 0) totalWin = totalWinBase * FREE_SPIN_MULTIPLIER;

      if (totalWin > 0) {
        const multiplied = totalWin * wildMultiplier;
        credits += multiplied;
        totalWin = multiplied;
        updateCredits();
        saveState();
      }

      lastWin = totalWin;
      updateLastWin();
      updateMode();

      // highlight wins and scatters
      wins.forEach((w, idx) => markIndices(w.indices, LINE_COLORS[idx % LINE_COLORS.length]));
      if (scatterCount >= FREE_SPIN_TRIGGER) markIndices(scatterIndices, '#ff9f1c');

      // draw simple outlines for each win (use same structure expected by drawPaylines)
      const drawLines = wins.map((w, i) => ({ lineSlots: w.indices, color: LINE_COLORS[i % LINE_COLORS.length] }));
      // In pay-anywhere mode we do not draw connective payline polylines
      // because wins are groups of cells rather than sequential paylines.
      // Keep only cell highlighting (markIndices) to avoid the criss-cross lines.
      if (!PAY_ANYWHERE && drawLines.length) drawPaylines(drawLines);

      // messages
      if (totalWin > 0) {
        const parts = wins.map(w => `${w.count}Ã— ${w.symbol} â†’ +${formatCurrency(w.winAmount)}`);
        if (scatterCount >= FREE_SPIN_TRIGGER) parts.push(bonusText);
        let type = 'win';
        let label = 'WIN!';
        const refBet = (betPerLine * activeLines) || betTotal || 1;
        if (totalWin >= refBet * 10) { type = 'bigwin'; label = 'MEGA WIN!'; }
        else if (totalWin >= refBet * 5) { type = 'nice'; label = 'BIG WIN!'; }
        let msg = `${label} ${parts.join(' â€¢ ')} â€“ Totale: +${formatCurrency(totalWin)} crediti`;
        if (wasFreeSpin && totalWinBase > 0) msg += ` (x${FREE_SPIN_MULTIPLIER} in bonus)`;
        setMessage(msg, type);
      } else {
        if (wasFreeSpin && freeSpins > 0) setMessage(`Free spin senza vincita. Free spin rimasti: ${freeSpins}`);
        else if (wasFreeSpin && freeSpins === 0) { inFreeSpins = false; updateMode(); setMessage('Fine modalitÃ  bonus, si torna al gioco base.'); }
        else setMessage('Nessuna combinazioneâ€¦ ritenta ðŸ˜ˆ');
      }
    }

    // --- Simulazione (versione headless per RTP estimation)
    function evaluatePayout(resultSymbols, currentBetPerLine, currentLines) {
      // pay-anywhere evaluation for headless RTP calc
      let totalWinBase = 0;
      const baseTotalBet = currentBetPerLine * currentLines;

      // scatter
      let scatterCount = 0;
      resultSymbols.forEach((sym) => { if (sym.isScatter) scatterCount++; });

      // counts for symbols
      const counts = new Map();
      resultSymbols.forEach((sym) => {
        if (sym.isScatter || sym.isMultiplier) return;
        const key = sym.isWild ? 'WILD' : sym.name;
        counts.set(key, (counts.get(key) || 0) + 1);
      });

      counts.forEach((cnt, key) => {
        if (cnt < 3) return;
        const payoutKey = cnt >= 5 ? 5 : cnt;
        let basePayout = 0;
        if (key === 'WILD') basePayout = SYMBOL_PAYOUTS['User1'] ? SYMBOL_PAYOUTS['User1'][payoutKey] || 0 : 0;
        else basePayout = (SYMBOL_PAYOUTS[key] && SYMBOL_PAYOUTS[key][payoutKey]) || 0;
        if (basePayout > 0) {
          const multCount = resultSymbols.filter(s => s.isMultiplier).length;
          const symMult = multCount > 0 ? Math.pow(MULT_VALUE, multCount) : 1;
          totalWinBase += basePayout * symMult * currentBetPerLine;
        }
      });

      if (scatterCount >= FREE_SPIN_TRIGGER) {
        const key = scatterCount >= 5 ? 5 : scatterCount;
        const scatterMult = SCATTER_PAYOUT[key] || 0;
        if (scatterMult > 0) totalWinBase += scatterMult * baseTotalBet;
      }

      let wildMultiplierSum = 0;
      resultSymbols.forEach((s) => {
        if (s.isWild) wildMultiplierSum += 1 + Math.floor(Math.random() * 3);
      });
      const wildMultiplier = wildMultiplierSum > 0 ? wildMultiplierSum : 1;

      return totalWinBase * wildMultiplier;
    }

    function randomFinalSymbols() {
      const finalSymbols = [];
      for (let i = 0; i < TOTAL_SLOTS; i++) finalSymbols.push(randomSymbol(i));
      return finalSymbols;
    }

    async function estimateRTP(spins, betPerLineForSim = betPerLine, linesForSim = activeLines, onProgress) {
      let totalBet = 0;
      let totalWin = 0;
      const chunk = 2000;
      for (let i = 0; i < spins; i += chunk) {
        const end = Math.min(spins, i + chunk);
        for (let j = i; j < end; j++) {
          const finalSymbols = randomFinalSymbols();
          const win = evaluatePayout(finalSymbols, betPerLineForSim, linesForSim);
          totalWin += win;
          totalBet += betPerLineForSim * linesForSim;
        }
        if (onProgress) onProgress(Math.min(1, (end) / spins));
        // yield to UI
        await new Promise((r) => setTimeout(r, 0));
      }
      return { totalBet, totalWin, rtp: totalWin / totalBet };
    }

    // ---- EVENTI ---------------------------------------------------------

    if (betMinusBtn) {
      betMinusBtn.addEventListener("click", () => {
        if (inFreeSpins) {
          setMessage(
            "Non puoi cambiare la puntata durante i free spin.",
            "error"
          );
          return;
        }
        if (betPerLine > MIN_BET_PER_LINE) {
          betPerLine = Math.max(MIN_BET_PER_LINE, parseFloat((betPerLine - BET_STEP).toFixed(2)));
          updateBetDisplay();
          saveState();
        }
      });
    }

    if (betPlusBtn) {
      betPlusBtn.addEventListener("click", () => {
        if (inFreeSpins) {
          setMessage(
            "Non puoi cambiare la puntata durante i free spin.",
            "error"
          );
          return;
        }
        if (betPerLine < MAX_BET_PER_LINE) {
          betPerLine = Math.min(MAX_BET_PER_LINE, parseFloat((betPerLine + BET_STEP).toFixed(2)));
          updateBetDisplay();
          saveState();
        }
      });
    }

    // Paylines are fixed at 25. Disable any attempts to change them.
    if (linesMinusBtn) {
      linesMinusBtn.addEventListener("click", () => {
        setMessage("Le linee sono fisse a 25 e non possono essere modificate.", "error");
      });
    }
    if (linesPlusBtn) {
      linesPlusBtn.addEventListener("click", () => {
        setMessage("Le linee sono fisse a 25 e non possono essere modificate.", "error");
      });
    }

    if (autoMinusBtn) {
      autoMinusBtn.addEventListener("click", () => {
        if (autoSpinCount > MIN_AUTO) {
          autoSpinCount -= AUTO_STEP;
          updateAutoCountDisplay();
          saveState();
        }
      });
    }
    if (autoPlusBtn) {
      autoPlusBtn.addEventListener("click", () => {
        if (autoSpinCount < MAX_AUTO) {
          autoSpinCount += AUTO_STEP;
          updateAutoCountDisplay();
          saveState();
        }
      });
    }

    if (spinBtn) {
      spinBtn.addEventListener("click", () => {
        autoSpinsLeft = 0;
        updateAutoLabel();
        spinOnce(false);
      });
    }

    if (autoBtn) {
      autoBtn.addEventListener("click", () => {
        if (inFreeSpins) {
          setMessage(
            "Non puoi avviare l'auto-spin durante i free spin.",
            "error"
          );
          return;
        }
        if (autoSpinsLeft > 0) {
          autoSpinsLeft = 0;
          updateAutoLabel();
          setMessage("Auto-spin fermato.");
        } else {
          autoSpinsLeft = autoSpinCount;
          updateAutoLabel();
          spinOnce(true);
        }
      });
    }

    if (resetBtn) {
      resetBtn.addEventListener("click", () => {
      credits = 1000;
      betPerLine = 1.0;
      activeLines = TOTAL_LINES;
      autoSpinCount = 10;
      autoSpinsLeft = 0;
      lastWin = 0;
      inFreeSpins = false;
      freeSpins = 0;
      bonusBetPerLine = 1;
      bonusLines = TOTAL_LINES;
      clearWins();
      updateCredits();
      updateBetDisplay();
      updateLinesDisplay();
      updateLastWin();
      updateAutoCountDisplay();
      updateMode();
      updateAutoLabel();
      saveState();
      setMessage("Crediti, linee e puntata resettati.");
      });
    }

    // play-bar controls
    if (betTotalMinusBtn && betTotalPlusBtn && betTotalDisplay) {
      const stepTotal = 0.01; // adjust total bet in euros (cents)
      betTotalMinusBtn.addEventListener('click', () => {
        const total = Math.max(0, parseFloat(((betPerLine * activeLines) - stepTotal).toFixed(2)));
        betPerLine = Math.max(MIN_BET_PER_LINE, parseFloat((total / activeLines).toFixed(2)));
        updateBetDisplay();
        saveState();
      });
      betTotalPlusBtn.addEventListener('click', () => {
        const total = parseFloat(((betPerLine * activeLines) + stepTotal).toFixed(2));
        betPerLine = Math.min(MAX_BET_PER_LINE, parseFloat((total / activeLines).toFixed(2)));
        updateBetDisplay();
        saveState();
      });
    }

    if (turboBtn) {
      function updateTurboUI() {
        if (turboMode) {
          turboBtn.classList.add('active');
            turboBtn.setAttribute('aria-pressed', 'true');
        } else {
          turboBtn.classList.remove('active');
          turboBtn.setAttribute('aria-pressed', 'false');
        }
      }
      turboBtn.addEventListener('click', () => {
        turboMode = !turboMode;
        updateTurboUI();
        saveState();
      });
      updateTurboUI();
    }

    if (autoToggleBtn) {
      autoToggleBtn.addEventListener('click', () => {
        if (autoSpinsLeft > 0) {
          autoSpinsLeft = 0;
          autoToggleBtn.setAttribute('aria-pressed', 'false');
          setMessage('Auto-spin fermato.');
        } else {
          autoSpinsLeft = autoSpinCount;
          autoToggleBtn.setAttribute('aria-pressed', 'true');
          setMessage(`Auto-spin avviato (${autoSpinsLeft})`);
          spinOnce(true);
        }
        updateAutoLabel();
      });
    }

    if (playSmallBtn) {
      playSmallBtn.addEventListener('click', () => {
        spinOnce(false);
      });
    }

    // (Keyboard shortcuts removed per user request)

    // RTP button
    const rtpBtn = document.getElementById('rtpBtn');
    const rtpCountEl = document.getElementById('rtp-count');
    const rtpResultEl = document.getElementById('rtpResult');
    if (rtpBtn && rtpCountEl && rtpResultEl) {
      rtpBtn.addEventListener('click', async () => {
        const n = Math.max(1000, Number(rtpCountEl.value) || 100000);
        rtpResultEl.textContent = 'Calcolo in corso...';
        rtpBtn.disabled = true;
        const start = performance.now();
        const result = await estimateRTP(n, betPerLine, activeLines, (p) => {
          rtpResultEl.textContent = `Calcolo: ${Math.round(p*100)}%`;
        });
        const took = ((performance.now() - start) / 1000).toFixed(1);
        const rtpPct = (result.rtp * 100).toFixed(3);
        rtpResultEl.textContent = `RTP: ${rtpPct}% (spins: ${n}) â€” tempo: ${took}s`;
        rtpBtn.disabled = false;
      });
    }

    // ---- INIT -----------------------------------------------------------

    loadState();
    updateCredits();
    updateBetDisplay();
    updateLinesDisplay();
    updateLastWin();
    updateAutoCountDisplay();
    updateMode();
    updateAutoLabel();
    setMessage(
      "Slot 6Ã—5 pay-anywhere con wild, scatter e multiplier. Premi SPIN!"
    );

    // assicurati che play-bar mostri i valori corretti
    if (displayCreditsEl) displayCreditsEl.textContent = formatCurrency(credits);
    if (betTotalDisplay) betTotalDisplay.textContent = formatCurrency(betPerLine * activeLines);
  </script>
</body>
</html>
