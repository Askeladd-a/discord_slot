<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Gates-like Slot — Demo (clean)</title>
  <style>
    :root{--cell:160px;--gap:12px}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Arial;background:linear-gradient(#0b0c10,#050507);color:#eee;display:flex;justify-content:center;padding:28px}
    .app{max-width:1100px;width:100%}
    header{display:flex;justify-content:space-between;align-items:center;margin-bottom:12px}
    .arena{display:grid;grid-template-columns:1fr;gap:12px}
    .sidebar{background:#0f1013;padding:12px;border-radius:10px}
    .main{background:#0b0c10;padding:18px;border-radius:12px}
    .slot{display:grid;grid-template-columns:repeat(5,var(--cell));grid-auto-rows:var(--cell);gap:var(--gap);justify-content:center}
    .cell{width:var(--cell);height:var(--cell);background:#0a0b0f;border-radius:8px;overflow:hidden;display:flex;align-items:center;justify-content:center;position:relative}
    .cell img{width:100%;height:100%;object-fit:contain;display:block;background:#070708;transform:translateY(0);transition:transform 900ms cubic-bezier(.2,.9,.2,1),opacity 900ms}
    .cell.win{outline:3px solid rgba(255,200,40,0.9);box-shadow:0 6px 18px rgba(255,180,20,0.18);transform:scale(1.03);z-index:2}
    .floatWin{position:absolute;left:50%;top:18%;transform:translateX(-50%);background:rgba(0,0,0,0.7);color:#ffd966;padding:8px 14px;border-radius:8px;font-weight:700;font-size:18px;pointer-events:none}
    .bigWin{position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);background:linear-gradient(45deg,#ffd966,#ffb347);color:#2b1f00;padding:22px 36px;border-radius:12px;font-size:34px;font-weight:800;box-shadow:0 20px 60px rgba(0,0,0,0.6);display:flex;align-items:center;justify-content:center}
    /* .multBadge removed (multipliers disabled) */
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px}
    button{background:#6c63ff;border:none;color:white;padding:8px 12px;border-radius:8px;cursor:pointer}
    .stats{font-size:13px;margin-top:8px}
    .low{opacity:.25}
    .payline{outline:3px solid transparent}
    .cell.spinning img{filter: blur(3px) saturate(1.05); transform: scale(1.02);} 
    /* win pulse */
    @keyframes win-pulse { 0% { box-shadow: 0 6px 18px rgba(255,180,20,0.18); transform: scale(1.02);} 50% { box-shadow: 0 12px 30px rgba(255,210,60,0.28); transform: scale(1.06);} 100% { box-shadow: 0 6px 18px rgba(255,180,20,0.18); transform: scale(1.02);} }
    .cell.win{outline:3px solid rgba(255,200,40,0.95); animation: win-pulse 900ms ease-in-out 0s 2;}
    /* coin particle */
    .coin-particle{position:fixed;width:18px;height:18px;border-radius:50%;background:radial-gradient(circle at 30% 35%, #fff6, #ffd54a);box-shadow:0 6px 14px rgba(0,0,0,0.4);pointer-events:none;transform-origin:center center;}
    @keyframes floatUp { from { transform: translateY(0) scale(1); opacity:1 } to { transform: translateY(-72px) scale(1.2); opacity:0 } }
    .payout-badge{position:absolute;right:6px;top:6px;min-width:40px;text-align:center;font-weight:700;padding:4px 8px;border-radius:10px;background:rgba(0,0,0,0.06);color:#222;font-size:12px;pointer-events:none;z-index:5;box-shadow:0 6px 18px rgba(0,0,0,0.12);backdrop-filter:blur(4px);transition:transform 220ms cubic-bezier(.2,.9,.2,1),box-shadow 220ms}
    #winDetails{margin-top:10px;background:rgba(8,9,12,0.6);padding:8px 12px;border-radius:8px;color:#ffd;min-height:26px;font-size:13px}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Gates-like Slot — Demo (Reels 5×3)</h1>
      <div id="balance">Credits: 1000.00</div>
    </header>
    <div class="arena">
      <main class="main" style="grid-column:1 / -1">
        <div style="display:flex;justify-content:center;">
          <div style="width:calc(var(--cell)*5 + var(--gap)*4);max-width:100%;background:#0b0c10;padding:10px;border-radius:12px;">
            <div style="position:relative;">
              <div class="slot" id="slot"></div>
              <svg id="payline-overlay" style="position:absolute;left:0;top:0;width:100%;height:100%;pointer-events:none;overflow:visible"></svg>
              <div id="winDetails" aria-live="polite">&nbsp;</div>
            </div>
          </div>
        </div>
        <div class="controls" style="display:flex;justify-content:space-between;align-items:center">
          <div style="display:flex;gap:8px;align-items:center">
            <button id="betMinus">-</button>
            <div>Bet: <span id="betDisplay">1.00</span></div>
            <button id="betPlus">+</button>
          </div>

          <div style="display:flex;flex-direction:column;align-items:center;gap:8px">
            <div style="display:flex;gap:8px;align-items:center">
              <button id="spin">SPIN</button>
              <button id="autoSpin">Auto Spin</button>
            </div>
            <div style="font-size:13px;color:#ccc">Mode: <span id="mode">Base</span> &nbsp; · &nbsp; Free Spins: <span id="fs">0</span> &nbsp; · &nbsp; Last Win: <span id="lastWin">0</span></div>
          </div>

          <div style="display:flex;flex-direction:column;align-items:flex-end;gap:8px">
            <div style="display:flex;align-items:center;gap:6px">
              <label style="font-size:13px">Auto</label>
              <button id="autoPreset10">10</button>
              <button id="autoPreset25">25</button>
              <button id="autoPreset50">50</button>
              <button id="autoPreset100">100</button>
            </div>
            <div style="display:flex;align-items:center;gap:8px">
              <div id="autoStatus" style="min-width:60px;padding:6px 10px;border-radius:8px;background:#07070a;color:#ffd966;text-align:center">—</div>
              <div style="display:flex;align-items:center;gap:6px">
                <label style="font-size:13px">Spin Speed</label>
                <button id="speedSlow">Slow</button>
                <button id="speedNormal">Normal</button>
                <button id="speedFast">Fast</button>
              </div>
            </div>
          </div>
        </div>
      </main>
    </div>
  </div>
  <script>
    // Basic WebAudio helpers (lazy-init on first user gesture)
    let _audioCtx = null;
    let SPIN_SFX_ON = true;
    let SPIN_SFX_STYLE = 'soft'; // 'soft' or 'metal'
    function ensureAudio(){
      if(_audioCtx) return _audioCtx;
      try{ _audioCtx = new (window.AudioContext || window.webkitAudioContext)(); }
      catch(e){ _audioCtx = null; }
      return _audioCtx;
    }
    function gainNode(volume=0.05){ const ctx = ensureAudio(); if(!ctx) return null; const g = ctx.createGain(); g.gain.value = volume; g.connect(ctx.destination); return g; }
    // softer spin click: supports 'soft' and 'metal' styles
    function playClick(freq=900, dur=0.06, vol=0.032){
      if(!SPIN_SFX_ON) return;
      const ctx = ensureAudio(); if(!ctx) return; const now = ctx.currentTime;
      if(SPIN_SFX_STYLE === 'metal'){
        // metallic click: bandpassed strike + inharmonic partials
        try{
          // short burst of filtered noise for metallic strike
          const nb = Math.max(1, Math.floor(ctx.sampleRate * Math.min(dur, 0.035)));
          const noiseBuf = ctx.createBuffer(1, nb, ctx.sampleRate);
          const data = noiseBuf.getChannelData(0);
          for(let i=0;i<nb;i++) data[i] = (Math.random()*2 - 1) * (1 - i/nb);
          const src = ctx.createBufferSource(); src.buffer = noiseBuf;
          const bp = ctx.createBiquadFilter(); bp.type = 'bandpass'; bp.frequency.value = Math.max(1200, freq * 1.2); bp.Q.value = 6;
          const ng = ctx.createGain(); ng.gain.setValueAtTime(vol, now); ng.gain.exponentialRampToValueAtTime(0.001, now + dur*0.6);
          src.connect(bp); bp.connect(ng); ng.connect(ctx.destination); src.start(now);
          setTimeout(()=>{ try{ src.stop(); src.disconnect(); bp.disconnect(); ng.disconnect(); }catch(e){} }, Math.ceil((dur+0.06)*1000));
        }catch(e){}
        // harmonic partials to add metallic tone
        try{
          const freqs = [freq*1.8, freq*2.6, freq*3.7];
          freqs.forEach((f,i)=>{
            const o = ctx.createOscillator(); o.type = i%2? 'square':'triangle'; o.frequency.setValueAtTime(f, now + i*0.002);
            const g = ctx.createGain(); g.gain.setValueAtTime(vol * (0.18/(i+1)), now);
            const bp2 = ctx.createBiquadFilter(); bp2.type='bandpass'; bp2.frequency.value = f; bp2.Q.value = 8;
            o.connect(bp2); bp2.connect(g); g.connect(ctx.destination); o.start(now + i*0.002);
            g.gain.exponentialRampToValueAtTime(0.001, now + dur + 0.02);
            setTimeout(()=>{ try{ o.stop(); o.disconnect(); bp2.disconnect(); g.disconnect(); }catch(e){} }, Math.ceil((dur+0.06 + i*0.02)*1000));
          });
        }catch(e){}
      } else {
        // short filtered noise attack + gentle sine body (soft)
        try{
          const nb = Math.max(1, Math.floor(ctx.sampleRate * Math.min(dur, 0.05)));
          const noiseBuf = ctx.createBuffer(1, nb, ctx.sampleRate);
          const data = noiseBuf.getChannelData(0);
          for(let i=0;i<nb;i++) data[i] = (Math.random()*2 - 1) * (1 - i/nb);
          const src = ctx.createBufferSource(); src.buffer = noiseBuf;
          const nf = ctx.createBiquadFilter(); nf.type = 'highpass'; nf.frequency.value = 700;
          const ng = ctx.createGain(); ng.gain.setValueAtTime(vol * 0.9, now);
          ng.gain.exponentialRampToValueAtTime(0.001, now + dur * 0.6);
          src.connect(nf); nf.connect(ng); ng.connect(ctx.destination);
          src.start(now);
          setTimeout(()=>{ try{ src.stop(); src.disconnect(); nf.disconnect(); ng.disconnect(); }catch(e){} }, Math.ceil((dur+0.06)*1000));
        }catch(e){}
        try{
          const o = ctx.createOscillator(); o.type = 'sine'; o.frequency.setValueAtTime(Math.max(200, freq * 0.55), now);
          const og = ctx.createGain(); og.gain.setValueAtTime(0.0001, now);
          og.gain.linearRampToValueAtTime(vol * 0.6, now + 0.006);
          og.gain.exponentialRampToValueAtTime(0.001, now + dur);
          o.connect(og); og.connect(ctx.destination); o.start(now);
          setTimeout(()=>{ try{ o.stop(); o.disconnect(); og.disconnect(); }catch(e){} }, Math.ceil((dur+0.04)*1000));
        }catch(e){}
      }
    }
    function playStopTone(freq=640, dur=0.22, vol=0.06){ const ctx = ensureAudio(); if(!ctx) return; const o = ctx.createOscillator(); const g = ctx.createGain(); const b = ctx.createBiquadFilter(); b.type='lowpass'; b.frequency.value = 2000; o.type='triangle'; o.frequency.setValueAtTime(freq, ctx.currentTime); g.gain.value = vol; o.connect(b); b.connect(g); g.connect(ctx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + dur); setTimeout(()=>{ o.stop(); o.disconnect(); g.disconnect(); b.disconnect(); }, Math.ceil(dur*1000)+40); }
    function playCoinSound(){ const ctx = ensureAudio(); if(!ctx) return; const now = ctx.currentTime; const g = ctx.createGain(); g.gain.value = 0.06; g.connect(ctx.destination); const env = g.gain; const o1 = ctx.createOscillator(); o1.type='square'; o1.frequency.setValueAtTime(1100, now); const o2 = ctx.createOscillator(); o2.type='sawtooth'; o2.frequency.setValueAtTime(1600, now); const mix = ctx.createGain(); mix.gain.value = 0.5; o1.connect(mix); o2.connect(mix); mix.connect(g); env.setValueAtTime(0.0001, now); env.linearRampToValueAtTime(0.06, now+0.005); env.exponentialRampToValueAtTime(0.001, now+0.22); o1.start(); o2.start(); setTimeout(()=>{ o1.stop(); o2.stop(); o1.disconnect(); o2.disconnect(); mix.disconnect(); g.disconnect(); }, 300);
    }
    function playLeverSound(){ if(!SPIN_SFX_ON) return; const ctx = ensureAudio(); if(!ctx) return; const now = ctx.currentTime; const o = ctx.createOscillator(); const f = ctx.createBiquadFilter(); f.type='lowpass'; f.frequency.value = 900; o.type='square'; o.frequency.setValueAtTime(120, now); const g = ctx.createGain(); g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.055, now+0.02); g.gain.exponentialRampToValueAtTime(0.001, now+0.22); o.connect(f); f.connect(g); g.connect(ctx.destination); o.start(); setTimeout(()=>{ try{ o.stop(); o.disconnect(); f.disconnect(); g.disconnect(); }catch(e){} }, 300); }
    function playSmallWinSound(){ const ctx = ensureAudio(); if(!ctx) return; const now = ctx.currentTime; const o = ctx.createOscillator(); o.type='sine'; o.frequency.setValueAtTime(900, now); const g = ctx.createGain(); g.gain.value = 0.045; o.connect(g); g.connect(ctx.destination); o.start(); g.gain.exponentialRampToValueAtTime(0.001, now+0.28); setTimeout(()=>{ o.stop(); o.disconnect(); g.disconnect(); }, 320); }
    function playBigWinSound(){ const ctx = ensureAudio(); if(!ctx) return; const now = ctx.currentTime; const o = ctx.createOscillator(); o.type='triangle'; const g = ctx.createGain(); g.gain.value = 0.07; o.frequency.setValueAtTime(700, now); o.connect(g); g.connect(ctx.destination); o.start(); o.frequency.exponentialRampToValueAtTime(1300, now+0.6); g.gain.exponentialRampToValueAtTime(0.001, now+0.9); setTimeout(()=>{ o.stop(); o.disconnect(); g.disconnect(); }, 950); }
    // resume audio on first user gesture to satisfy autoplay policies
    ['click','pointerdown','keydown','touchstart'].forEach(ev=>{ window.addEventListener(ev, ()=>{ if(!_audioCtx) try{ ensureAudio(); }catch(e){} }, { once:true, passive:true }); });
    // pickWeighted considers ante boosting scatter
    let anteOn = false; const ANTE_MULT = 25; const ANTE_SCATTER_BOOST = 3;
    // Image prefix and symbol definitions (was missing — causes symbols to not load)
    const IMG_PREFIX = 'img/';
    const ROWS = 3, COLS = 5, TOTAL = ROWS * COLS;
    const SYMBOLS = [];
    for (let i = 1; i <= 13; i++) SYMBOLS.push({ name: 'S' + i, img: `${IMG_PREFIX}user${i}.png` });
    const SCATTER = { name: 'ZEUS', isScatter: true, img: `${IMG_PREFIX}scatter.png` };
    const WEIGHTED = [];
    for (let i = 0; i < SYMBOLS.length; i++) WEIGHTED.push({ sym: SYMBOLS[i], weight: 12 - i });
    WEIGHTED.push({ sym: SCATTER, weight: 2 });

    const PAYTABLE = {
      S1: {12:100,10:50,8:20},
      S2: {12:50,10:20,8:5},
      S3: {12:30,10:10,8:4},
      S4: {12:24,10:4,8:3},
      S5: {12:20,10:3,8:2},
      S6: {12:16,10:2.4,8:1.6},
      S7: {12:10,10:2,8:1},
      S8: {12:8,10:1.8,8:0.8},
      S9: {12:4,10:1.5,8:0.5},
      S10:{12:4,10:1.5,8:0.5},
      S11:{12:4,10:1.5,8:0.5},
      S12:{12:4,10:1.5,8:0.5}
    };
    const SCATTER_PAYOUT = {6:200,5:100,4:6};

    // Bind commonly-used DOM elements
    const slot = document.getElementById('slot');
    const balanceEl = document.getElementById('balance');
    const modeEl = document.getElementById('mode');
    const fsEl = document.getElementById('fs');
    const lastWinEl = document.getElementById('lastWin');
    const leftInfo = document.getElementById('leftInfo');
    // --- Secure PRNG (xoshiro128++) with seedable state
    (function(){
      let s = new Uint32Array(4);
      function rotl(x,k){ return ((x<<k) | (x>>> (32-k))) >>> 0; }
      function next(){
        const result = (rotl((s[0] + s[3])>>>0, 7) + s[0]) >>> 0;
        const t = (s[1] << 9) >>> 0;
        s[2] ^= s[0]; s[3] ^= s[1]; s[1] ^= s[2]; s[0] ^= s[3];
        s[2] ^= t; s[3] = rotl(s[3], 11);
        return result / 0x100000000; // [0,1)
      }
      function seedFromBytes(bytes){
        const dv = new DataView(new ArrayBuffer(16));
        for(let i=0;i<4;i++) dv.setUint32(i*4, (bytes[i*4]||0) | ((bytes[i*4+1]||0)<<8) | ((bytes[i*4+2]||0)<<16) | ((bytes[i*4+3]||0)<<24), true);
        s = new Uint32Array(dv.buffer);
      }
      function seedFromHex(hex){
        // accept 8..32 hex chars, pad/truncate to 32 chars (16 bytes)
        const h = hex.replace(/[^0-9a-fA-F]/g,'');
        const padded = (h + '0'.repeat(32)).slice(0,32);
        const bytes = new Uint8Array(16);
        for(let i=0;i<16;i++) bytes[i] = parseInt(padded.substr(i*2,2),16) || 0;
        seedFromBytes(bytes);
      }
      function seedToHex(){
        const dv = new DataView(s.buffer.slice(0));
        let out = '';
        for(let i=0;i<4;i++){ out += dv.getUint32(i*4, true).toString(16).padStart(8,'0'); }
        return out.slice(0,32);
      }
      function seedFromCrypto(){ const arr = new Uint32Array(4); window.crypto.getRandomValues(arr); s = arr; }
      // expose rng and seeding
      window._rng = next; window._seedFromBytes = seedFromBytes; window._seedFromCrypto = seedFromCrypto; window._seedFromHex = seedFromHex; window._seedToHex = seedToHex;
      // Background advancer
      let advanceInterval = null;
      function startAdvance(){ if(advanceInterval) return; advanceInterval = setInterval(()=>{ for(let i=0;i<8;i++) next(); }, 64); }
      function stopAdvance(){ if(advanceInterval){ clearInterval(advanceInterval); advanceInterval = null; } }
      startAdvance(); window.startRng = startAdvance; window.stopRng = stopAdvance;
    })();
    function rng(){ return (window._rng && window._rng()) || Math.random(); }

    // Local-only PRNG: no external beacon used
    function pickWeighted(){
      const effective = WEIGHTED.map(e => ({ sym: e.sym, weight: e.weight }));
      if(anteOn){
        for(const e of effective){ if(e.sym && e.sym.isScatter) e.weight *= ANTE_SCATTER_BOOST; }
      }
      const total = effective.reduce((s,i)=>s+i.weight,0);
      let r=rng()*total;
      for(const e of effective){
        if(r < e.weight){
          const s = Object.assign({}, e.sym);
          return s;
        }
        r -= e.weight;
      }
      const fallback = Object.assign({}, effective[0].sym);
      return fallback;
    }

    // --- Reels / Payline support
    // deterministic per-reel strips generated once from the PRNG seed
    let reelStrips = null; const REEL_STRIP_LEN = 64;
    function initReelStrips(){
      reelStrips = [];
      for(let r=0;r<COLS;r++){
        const strip = [];
        for(let i=0;i<REEL_STRIP_LEN;i++){ const w = WEIGHTED[Math.floor(rng()*WEIGHTED.length)]; strip.push(w.sym); }
        reelStrips.push(strip);
      }
    }

    // Preload images to avoid visual jumps during animation
    const _imgCache = new Map();
    function preloadImages(){
      const urls = [];
      for(let i=1;i<=13;i++) urls.push(`${IMG_PREFIX}user${i}.png`);
      urls.push(`${IMG_PREFIX}scatter.png`);
      urls.forEach(u=>{ const im=new Image(); im.src=u; _imgCache.set(u,im); });
    }
    
    function buildReelsFinal(){
      if(!reelStrips) initReelStrips();
      const final = Array(ROWS*COLS).fill(null);
      const starts = [];
      for(let c=0;c<COLS;c++){
        const strip = reelStrips[c];
        const start = Math.floor(rng()*strip.length);
        starts.push(start);
        for(let r=0;r<ROWS;r++) final[r*COLS + c] = strip[(start + r) % strip.length];
      }
      return {final, starts};
    }

    // paylines: classic 10-line for 5x3 (indices computed per current ROWS/COLS)
    function getPaylines(rows, cols){
      // positions are (r,c) -> idx = r*cols + c
      if(rows!==3 || cols!==5) return [];
      const lines = [
        [ [0,0],[0,1],[0,2],[0,3],[0,4] ],
        [ [1,0],[1,1],[1,2],[1,3],[1,4] ],
        [ [2,0],[2,1],[2,2],[2,3],[2,4] ],
        [ [0,0],[1,1],[2,2],[1,3],[0,4] ],
        [ [2,0],[1,1],[0,2],[1,3],[2,4] ],
        [ [0,0],[0,1],[1,2],[0,3],[0,4] ],
        [ [2,0],[2,1],[1,2],[2,3],[2,4] ],
        [ [1,0],[2,1],[2,2],[2,3],[1,4] ],
        [ [1,0],[0,1],[0,2],[0,3],[1,4] ],
        [ [0,0],[1,1],[1,2],[1,3],[0,4] ]
      ];
      return lines.map(line => line.map(([r,c])=> r*cols + c));
    }

    function evaluateReels(grid){
      const paylines = getPaylines(ROWS,COLS);
      let total=0; let scatterCount=0; const wins=[];
      // count scatters
      grid.forEach(s=>{ if(s && s.isScatter) scatterCount++; });
      const scatterWin = payoutForScatter(scatterCount);
      total += scatterWin;
      // evaluate each payline left-to-right (match consecutive identical symbols from reel0)
      for(const pl of paylines){
        const first = grid[pl[0]]; if(!first || first.isScatter) continue;
        let count=1;
        for(let i=1;i<pl.length;i++){ const sym = grid[pl[i]]; if(sym && !sym.isScatter && sym.name===first.name) count++; else break; }
        if(count>=3){ const p = payoutForCount(first.name, count); if(p>0){ total += p; wins.push({line:pl, symbol:first.name, count, payout:p, indices: pl.slice(0,count)}); } }
      }
      return {win: total, finalScatter: scatterCount, wins};
    }

    const PAYLINE_COLORS = ['#ffd966','#8be9fd','#ff9ff3','#a29bfe','#b8ffb0','#ffb86b','#ff6b6b','#9ae66e','#74c0fc','#f78fb3'];

    // build grid DOM (dynamic)
    function buildGrid(){
      slot.innerHTML='';
      for(let i=0;i<TOTAL;i++){
        const c=document.createElement('div'); c.className='cell';
        const im=document.createElement('img'); im.id=`img-${i}`;
        // default to a rotating set of symbol images until reels generate actual symbols
        const symIdx = (i % SYMBOLS.length);
        im.src = SYMBOLS[symIdx] ? SYMBOLS[symIdx].img : `${IMG_PREFIX}user1.png`;
        c.appendChild(im); slot.appendChild(c);
      }
    }
    buildGrid();
    preloadImages();

    // Reels-only: no mode switching
    // ensure Ante/Buy buttons are disabled for Reels
    document.addEventListener('DOMContentLoaded', ()=>{
      const buyBtn = document.getElementById('buyBonus'); const anteBtn = document.getElementById('toggleAnte');
      if(buyBtn) buyBtn.disabled = true; if(anteBtn) anteBtn.disabled = true;
    });

    // wire spin-speed and auto-spin preset buttons
    document.addEventListener('DOMContentLoaded', ()=>{
      const audioBtn = document.getElementById('toggleAudio');
      if(audioBtn){ audioBtn.disabled = true; audioBtn.textContent = 'Audio Removed'; }

      // speed presets
      const speedPresets = {
        slow: { baseDuration: 1000, perReelDelay: 280, perReelExtra: 220, cycleInterval: 180, fastSwipe: 340, settle: 520 },
        normal: { baseDuration: 820, perReelDelay: 220, perReelExtra: 160, cycleInterval: 140, fastSwipe: 260, settle: 420 },
        fast: { baseDuration: 560, perReelDelay: 140, perReelExtra: 100, cycleInterval: 96, fastSwipe: 180, settle: 300 }
      };
      function applySpeedPreset(p){ Object.assign(TIMINGS, p); showFloat('Speed: ' + (p === speedPresets.slow ? 'Slow' : p === speedPresets.fast ? 'Fast' : 'Normal'), 800); }
      const speedSlow = document.getElementById('speedSlow'); const speedNormal = document.getElementById('speedNormal'); const speedFast = document.getElementById('speedFast');
      if(speedSlow) speedSlow.addEventListener('click', ()=> applySpeedPreset(speedPresets.slow));
      if(speedNormal) speedNormal.addEventListener('click', ()=> applySpeedPreset(speedPresets.normal));
      if(speedFast) speedFast.addEventListener('click', ()=> applySpeedPreset(speedPresets.fast));

      

      // autospin presets (10,25,50,100)
      const autoPreset10 = document.getElementById('autoPreset10');
      const autoPreset25 = document.getElementById('autoPreset25');
      const autoPreset50 = document.getElementById('autoPreset50');
      const autoPreset100 = document.getElementById('autoPreset100');
      function startAutoWithCount(n){
        autoSpinCount = Math.max(0, Math.floor(n));
        const autoBtn = document.getElementById('autoSpin');
        const autoStatusEl = document.getElementById('autoStatus');
        if(autoStatusEl) autoStatusEl.textContent = autoSpinCount>0 ? String(autoSpinCount) : '∞';
        if(autoBtn){
          AUTO_SPIN_ON = true; autoBtn.textContent = 'Stop Auto';
          if(_autoSpinInterval){ clearInterval(_autoSpinInterval); _autoSpinInterval=null; }
          _autoSpinInterval = setInterval(async ()=>{
            if(!inFreeSpins && balance < betPerSpin){ AUTO_SPIN_ON=false; autoBtn.textContent='Auto Spin'; if(autoStatusEl) autoStatusEl.textContent='—'; clearInterval(_autoSpinInterval); _autoSpinInterval=null; return; }
            if(document.getElementById('spin').disabled) return;
            await spin();
            if(autoSpinCount>0){ autoSpinCount = Math.max(0, autoSpinCount - 1); if(autoStatusEl) autoStatusEl.textContent = autoSpinCount>0 ? String(autoSpinCount) : '—'; if(autoSpinCount === 0){ AUTO_SPIN_ON=false; autoBtn.textContent='Auto Spin'; clearInterval(_autoSpinInterval); _autoSpinInterval=null; } }
            updateUI();
          }, AUTO_SPIN_DELAY);
        }
      }
      if(autoPreset10) autoPreset10.addEventListener('click', ()=> startAutoWithCount(10));
      if(autoPreset25) autoPreset25.addEventListener('click', ()=> startAutoWithCount(25));
      if(autoPreset50) autoPreset50.addEventListener('click', ()=> startAutoWithCount(50));
      if(autoPreset100) autoPreset100.addEventListener('click', ()=> startAutoWithCount(100));
      
    });

    // payout helpers
    function payoutForCount(name, count){
      const table = PAYTABLE[name];
      if(!table) return 0;
      const keys = Object.keys(table).map(Number).sort((a,b)=>a-b);
      let matched = 0; for(const k of keys) if(count>=k) matched=k;
      return matched? table[matched] : 0;
    }

    function payoutForScatter(count){
      if(count>=6) return SCATTER_PAYOUT[6]||0;
      if(count>=5) return SCATTER_PAYOUT[5]||0;
      if(count>=4) return SCATTER_PAYOUT[4]||0;
      return 0;
    }

    // animate tumble: set image src and translateY from -drop*cell -> 0
    function animateTumble(finalGrid, drop, newFlag){
      const imgs=document.querySelectorAll('.cell img');
      const unit = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||96;
      imgs.forEach((img,i)=>{ img.style.transition='none'; img.src = finalGrid[i].img; img.style.transform = `translateY(${-drop[i]*unit}px)`; img.style.opacity = newFlag[i]?'0':'1';
        const cell = finalGrid[i]; img.title = '';
      });
      // force reflow
      slot.getBoundingClientRect();
      imgs.forEach((img,i)=>{ const col = i % COLS; const delay = col*60; img.style.transition = `transform 900ms cubic-bezier(.2,.9,.2,1) ${delay}ms, opacity 900ms ${delay}ms`; img.style.transform='translateY(0)'; img.style.opacity='1'; });
      return new Promise(r=>setTimeout(r,1250));
    }

    // Reel spin animation: spins each column from offset to final visible symbols
    // Timing configuration for reel spins (easy to tweak)
    const TIMINGS = {
      cycles: 5,               // slightly more cycles for a weighty feel
      baseDuration: 820,       // larger base duration for more dramatic decel (ms)
      perReelDelay: 220,       // increased stagger between reel starts (ms)
      perReelExtra: 160,       // extra duration per next reel (ms)
      cycleInterval: 140,      // spacing between visual cycles (ms)
      fastSwipe: 260,          // duration of each fast translate (ms)
      settle: 420,             // longer settle animation (ms)
      beepBaseFreq: 640,       // base beep frequency (shifted slightly lower)
      beepGain: 0.045          // lower beep volume
    };

    // runtime options
    let AUDIO_ON = false;
    let AUTO_SPIN_ON = false; let _autoSpinInterval = null; let AUTO_SPIN_DELAY = 700; // ms between spins
    let autoSpinCount = 0; // 0 = infinite

    async function animateReels(result){
      // Smooth reel animation using requestAnimationFrame + easing
      // result: { final: [...symbols], starts: [startIndices] }
      const imgs = document.querySelectorAll('.cell img');
      const unit = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'))||96;
      const { baseDuration, perReelDelay, perReelExtra, beepBaseFreq, beepGain } = TIMINGS;

      function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

      const perReelPromises = [];

      for(let c=0;c<COLS;c++){
        perReelPromises.push(new Promise((resolve)=>{
          const startDelay = perReelDelay * c;
          const totalDur = baseDuration + perReelExtra * c;
          const strip = reelStrips && reelStrips[c] ? reelStrips[c] : null;
          const startIndex = (result.starts && result.starts[c]) ? result.starts[c] : Math.floor(Math.random() * (strip?strip.length:12));

          // compute number of steps (symbol advances) to perform
          const steps = Math.max(24, Math.round(totalDur / 25) * 3);

          // animation variables
          let started = false; let rafId = null; let frameLastStep = -1;

          function startSpin(){
            const t0 = performance.now();
            started = true;
            function frame(now){
              const elapsed = now - t0;
              const u = Math.min(1, elapsed / totalDur);
              const e = easeOutCubic(u);
              const stepNow = Math.min(steps, Math.floor(e * steps));
              if(stepNow !== frameLastStep){
                // update visible imgs for this column based on stepNow
                const idxBase = (startIndex + stepNow) % (strip ? strip.length : 1);
                for(let r=0;r<ROWS;r++){
                  const imgIdx = r*COLS + c; const el = imgs[imgIdx];
                  if(!el) continue;
                  const sym = strip ? strip[(idxBase + r) % strip.length] : result.final[imgIdx];
                  el.src = (sym && sym.img) ? sym.img : `${IMG_PREFIX}user1.png`;
                }
                // audio click per step (slightly different pitch per reel)
                playClick(1400 - c*40, 0.025, 0.035);
                // add spinning class to column cells
                for(let r=0;r<ROWS;r++){ const cell = imgs[r*COLS + c].parentElement; if(cell) cell.classList.add('spinning'); }
                frameLastStep = stepNow;
              }
              if(u < 1){ rafId = requestAnimationFrame(frame); }
              else {
                // final: set final images for this column
                for(let r=0;r<ROWS;r++){ const imgIdx = r*COLS + c; const el = imgs[imgIdx]; if(!el) continue; const sym = result.final[imgIdx]; el.src = sym.img; el.style.transition = 'transform 260ms cubic-bezier(.2,.9,.2,1)'; el.style.transform = 'translateY(0)'; }
                // stop tone and remove spinning class
                playStopTone(beepBaseFreq + c*48, 0.12, 0.08);
                for(let r=0;r<ROWS;r++){ const cell = imgs[r*COLS + c].parentElement; if(cell) cell.classList.remove('spinning'); }
                resolve();
              }
            }
            rafId = requestAnimationFrame(frame);
          }

          // schedule start after column-specific delay
          setTimeout(()=>{ startSpin(); }, startDelay);
        }));
      }

      await Promise.all(perReelPromises);
      // small global settle
      await new Promise(r=>setTimeout(r,120));
      return;
    }

    function clearHighlights(){ document.querySelectorAll('.cell').forEach(c=>{ c.classList.remove('win','payline'); const badge = c.querySelector('.payout-badge'); if(badge) badge.remove(); }); const wd = document.getElementById('winDetails'); if(wd) wd.innerHTML='&nbsp;'; }

    // state
    let balance = 1000; let inFreeSpins=false; let freeSpins=0;
    // bet controls
    let betPerSpin = 1.0; const BET_STEP = 0.1; const MIN_BET = 0.1; const MAX_BET = 1000;

    function updateUI(){
      balanceEl.textContent = `Credits: ${balance.toFixed(2)}`;
      modeEl.textContent = `Mode: ${inFreeSpins?'Free Spins':'Base'}`;
      fsEl.textContent = `Free Spins: ${freeSpins}`;
      if(leftInfo) leftInfo.innerHTML = '';
      if(inFreeSpins){ /* no round multiplier to display */ }
      const betDisplayEl = document.getElementById('betDisplay'); if(betDisplayEl) betDisplayEl.textContent = betPerSpin.toFixed(2);
      const buyBonusEl = document.getElementById('buyBonus'); if(buyBonusEl) { buyBonusEl.textContent = `Buy Bonus (${(betPerSpin*100).toFixed(2)} credits)`; buyBonusEl.disabled = anteOn; }
      const toggleAnteEl = document.getElementById('toggleAnte'); if(toggleAnteEl) toggleAnteEl.textContent = `Ante x25 ${anteOn? 'ON' : 'OFF'}`;
      const autoBtn = document.getElementById('autoSpin'); if(autoBtn) autoBtn.textContent = AUTO_SPIN_ON ? 'Stop Auto' : 'Auto Spin';
      const autoStatusEl = document.getElementById('autoStatus'); if(autoStatusEl){ autoStatusEl.textContent = (AUTO_SPIN_ON ? (autoSpinCount>0 ? String(autoSpinCount) : '∞') : '—'); }
    }
    updateUI();

    // UI helpers for showing wins
    function showFloat(text, ttl=900){
      const el = document.createElement('div'); el.className='floatWin'; el.textContent = text; document.body.appendChild(el);
      setTimeout(()=>{ el.style.transition='opacity 600ms'; el.style.opacity='0'; setTimeout(()=>el.remove(),600); }, ttl);
    }
    function showBigWin(text, ttl=1600){
      const el = document.createElement('div'); el.className='bigWin'; el.textContent = text; document.body.appendChild(el);
      setTimeout(()=>{ el.style.transition='opacity 800ms'; el.style.opacity='0'; setTimeout(()=>el.remove(),800); }, ttl);
    }

    // Win sounds implemented above

    // coin particle effect
    function spawnCoinParticles(x,y,count=8){
      for(let i=0;i<count;i++){
        const p = document.createElement('div'); p.className='coin-particle'; document.body.appendChild(p);
        const angle = (Math.PI*2)*(i/count) + (Math.random()-0.5)*0.6; const speed = 40 + Math.random()*80;
        p.style.left = (x - 9) + 'px'; p.style.top = (y - 9) + 'px';
        p.style.opacity='1'; p.style.transform = 'translateY(0) scale(1)';
        const dx = Math.cos(angle)*speed; const dy = Math.sin(angle)*speed * -1;
        // animate using CSS keyframes
        p.animate([
          { transform: `translate(0px,0px) scale(1)`, opacity:1 },
          { transform: `translate(${dx}px,${dy}px) scale(1.15)`, opacity:0 }
        ], { duration: 700 + Math.random()*300, easing: 'cubic-bezier(.2,.8,.2,1)' });
        setTimeout(()=> p.remove(), 1200);
      }
    }

    // payline drawing: draws an animated glowing polyline over the grid
    function getCellCenter(idx){
      const imgs = document.querySelectorAll('.cell img'); const el = document.getElementById(`img-${idx}`);
      if(!el) return {x: window.innerWidth/2, y: window.innerHeight/2};
      const r = el.getBoundingClientRect(); return { x: r.left + r.width/2, y: r.top + r.height/2 };
    }
    function hexToRgba(hex, a=1){
      if(!hex) return `rgba(255,220,120,${a})`;
      const h = hex.replace('#',''); const bigint = parseInt(h.length===3? h.split('').map(c=>c+c).join('') : h,16);
      const r = (bigint >> 16) & 255; const g = (bigint >> 8) & 255; const b = bigint & 255; return `rgba(${r},${g},${b},${a})`;
    }
    function drawPayline(indices, color){
      const svg = document.getElementById('payline-overlay'); if(!svg) return new Promise(r=>r());
      // clear
      while(svg.firstChild) svg.removeChild(svg.firstChild);
      const svgRect = svg.getBoundingClientRect();
      const pts = indices.map(i=>{ const p = getCellCenter(i); return { x: p.x - svgRect.left, y: p.y - svgRect.top }; });
      if(pts.length < 2) return new Promise(r=>r());
      const pathData = pts.map((p,ix)=> `${ix===0?'M':'L'} ${p.x} ${p.y}`).join(' ');
      const glow = document.createElementNS('http://www.w3.org/2000/svg','path'); glow.setAttribute('d', pathData); glow.setAttribute('class','glow'); glow.setAttribute('stroke', hexToRgba(color,0.9)); svg.appendChild(glow);
      const line = document.createElementNS('http://www.w3.org/2000/svg','path'); line.setAttribute('d', pathData); line.setAttribute('class','line'); line.setAttribute('stroke', hexToRgba(color,1)); svg.appendChild(line);
      // animate stroke-dashoffset for a moving light
      const len = line.getTotalLength(); line.style.strokeDasharray = `${len}`; line.style.strokeDashoffset = `${len}`;
      line.animate([{ strokeDashoffset: len }, { strokeDashoffset: 0 }], { duration: 700, easing: 'cubic-bezier(.2,.9,.2,1)' });
      glow.style.opacity = '0.9'; glow.animate([{ opacity:0 },{ opacity:0.9 }], { duration: 350, fill:'forwards' });
      return new Promise((resolve)=>{ setTimeout(()=>{ if(svg) while(svg.firstChild) svg.removeChild(svg.firstChild); resolve(); }, 900); });
    }
    async function drawPaylines(wins){
      if(!wins || !wins.length) return;
      for(let i=0;i<wins.length;i++){
        const w = wins[i]; const color = PAYLINE_COLORS[i % PAYLINE_COLORS.length] || '#ffd966';
        try{ await drawPayline(w.indices, color); }catch(e){}
        // small gap between lines
        await new Promise(r=>setTimeout(r, 140));
      }
    }

    // evaluate tumble chains, handle multipliers and free spins
    async function evaluateSpin(grid, isFreeSpin=false){
      // For Reels-only mode, evaluation is handled by evaluateReels
      return evaluateReels(grid);
    }

    // spin workflow: deduct bet (or use free spin), animate and evaluate
    async function spin(){
      document.getElementById('spin').disabled=true;
      const baseCost = betPerSpin;
      const spinCost = anteOn ? baseCost * ANTE_MULT : baseCost;
      if(!inFreeSpins){
        if(balance < spinCost){ alert('Not enough credits for this spin'); document.getElementById('spin').disabled=false; return; }
        balance -= spinCost;
        // audio feedback: coin in hopper + lever pull
        playCoinSound();
        setTimeout(()=>{ playLeverSound(); }, 90);
      }
      updateUI();
      let res;
      // Reels-only flow
      const built = buildReelsFinal();
      await animateReels(built);
      res = await evaluateSpin(built.final, inFreeSpins);
      // highlight payline wins if any
      if(res.wins && res.wins.length){
        clearHighlights();
        let totalPayout = 0;
        const wd = document.getElementById('winDetails');
        const linesText = [];
        res.wins.forEach((w,idx)=>{
          const color = PAYLINE_COLORS[idx % PAYLINE_COLORS.length];
          totalPayout += w.payout || 0;
          linesText.push(`Line ${idx+1}: ${w.symbol} x${w.count} → ${w.payout}`);
          w.indices.forEach(i=>{ const el = document.getElementById(`img-${i}`); if(el){ const cell = el.parentElement; cell.classList.add('payline'); cell.style.outlineColor = color; cell.style.boxShadow = `0 6px 18px ${color}40`; // add badge to first index of the win
              if(i === w.indices[0]){
                const b = document.createElement('div'); b.className = 'payout-badge';
                b.textContent = (w.payout? w.payout.toFixed(2) : '0');
                // color badge to match payline
                try{
                  const col = PAYLINE_COLORS[idx % PAYLINE_COLORS.length] || '#ffd966';
                  b.style.background = hexToRgba(col, 0.12);
                  b.style.color = hexToRgba(col, 0.98);
                  b.style.border = `1px solid ${hexToRgba(col,0.18)}`;
                  b.style.boxShadow = `0 4px 12px ${hexToRgba(col,0.18)}`;
                }catch(e){}
                cell.appendChild(b);
              }
            } });
        });
        // draw animated paylines
        try{ if(res.wins && res.wins.length) drawPaylines(res.wins); }catch(e){}
        if(wd) wd.innerHTML = `<strong>Total:</strong> ${totalPayout.toFixed(2)} &nbsp; — &nbsp; ${linesText.join(' • ')}`;
        if(leftInfo) leftInfo.innerHTML = linesText.join('<br>');
      }
      await new Promise(r=>setTimeout(r,900));
      clearHighlights(); if(leftInfo) leftInfo.innerHTML = '';
      const win = res.win; const finalScatter = res.finalScatter;
      if(win>0){ balance += win; showFloat(`Win: ${win.toFixed(2)}`);
        // visual + audio feedback for wins
        // mark cells that were part of wins
        document.querySelectorAll('.cell').forEach(c=> c.classList.remove('win'));
        if(res.wins && res.wins.length){ res.wins.forEach(w=> w.indices.forEach(i=>{ const el=document.getElementById(`img-${i}`); if(el) el.parentElement.classList.add('win'); })); }
        // choose sound based on magnitude
        if(win >= betPerSpin * 10) {
          playBigWinSound();
          // spawn from first winning cell if available
          const firstIdx = (res.wins && res.wins[0] && res.wins[0].indices && res.wins[0].indices[0]) ? res.wins[0].indices[0] : null;
          const p = firstIdx !== null ? getCellCenter(firstIdx) : { x: window.innerWidth/2, y: window.innerHeight/2 };
          spawnCoinParticles(p.x, p.y, 18); showBigWin(`Big Win: ${win.toFixed(2)}`);
        } else {
          playSmallWinSound();
          const firstIdx = (res.wins && res.wins[0] && res.wins[0].indices && res.wins[0].indices[0]) ? res.wins[0].indices[0] : null;
          const p = firstIdx !== null ? getCellCenter(firstIdx) : { x: window.innerWidth/2, y: window.innerHeight/2 };
          spawnCoinParticles(p.x, p.y, 8);
        }
      }

      // scatter triggers
      if(!inFreeSpins && finalScatter >= 4){ inFreeSpins = true; freeSpins = Math.min(100, freeSpins + 15); }
      else if(inFreeSpins && finalScatter >= 3){ freeSpins = Math.min(100, freeSpins + 5); }

      // consume free spin
      if(inFreeSpins){ freeSpins = Math.max(0, freeSpins - 1); if(freeSpins === 0){ inFreeSpins = false; } }

      updateUI(); lastWinEl.textContent = `Last Win: ${win.toFixed(2)}`;
      document.getElementById('spin').disabled=false;
      // auto-stop if balance too low
      if(!inFreeSpins && AUTO_SPIN_ON && balance < betPerSpin){ AUTO_SPIN_ON=false; const autoBtn = document.getElementById('autoSpin'); if(autoBtn) autoBtn.textContent='Auto Spin'; if(_autoSpinInterval){ clearInterval(_autoSpinInterval); _autoSpinInterval=null; } }
    }

    // wire controls
    // Reels-only UI (no mode toggle)
    document.addEventListener('DOMContentLoaded', ()=>{
      const spinBtn = document.getElementById('spin'); if(spinBtn) spinBtn.addEventListener('click', spin);
      const autoBtn = document.getElementById('autoSpin');
      if(autoBtn){ autoBtn.addEventListener('click', ()=>{
        const autoStatusEl = document.getElementById('autoStatus');
        AUTO_SPIN_ON = !AUTO_SPIN_ON; autoBtn.textContent = AUTO_SPIN_ON ? 'Stop Auto' : 'Auto Spin';
        if(AUTO_SPIN_ON){ if(autoStatusEl) autoStatusEl.textContent = autoSpinCount>0 ? String(autoSpinCount) : '∞';
          // start interval loop (if autoSpinCount already set by presets)
          _autoSpinInterval = setInterval(async ()=>{
            if(!inFreeSpins && balance < betPerSpin){ AUTO_SPIN_ON=false; autoBtn.textContent='Auto Spin'; if(autoStatusEl) autoStatusEl.textContent='—'; clearInterval(_autoSpinInterval); _autoSpinInterval=null; return; }
            if(document.getElementById('spin').disabled) return;
            await spin();
            if(autoSpinCount>0){ autoSpinCount = Math.max(0, autoSpinCount - 1); if(autoStatusEl) autoStatusEl.textContent = autoSpinCount>0 ? String(autoSpinCount) : '—'; if(autoSpinCount === 0){ AUTO_SPIN_ON=false; autoBtn.textContent='Auto Spin'; clearInterval(_autoSpinInterval); _autoSpinInterval=null; } }
            updateUI();
          }, AUTO_SPIN_DELAY);
        } else { if(_autoSpinInterval){ clearInterval(_autoSpinInterval); _autoSpinInterval=null; } if(autoStatusEl) autoStatusEl.textContent='—'; }
      }); }
      const buyBtnEl = document.getElementById('buyBonus'); if(buyBtnEl) buyBtnEl.addEventListener('click', ()=>{
        const cost = betPerSpin * 100;
        if(balance < cost){ alert('Not enough to buy bonus (cost: '+cost.toFixed(2)+')'); return; }
        balance -= cost;
        inFreeSpins=true; freeSpins = Math.min(100, freeSpins + 15); updateUI();
      });
      const toggleAnteEl = document.getElementById('toggleAnte'); if(toggleAnteEl) toggleAnteEl.addEventListener('click', ()=>{ anteOn = !anteOn; updateUI(); });
      const betPlusEl = document.getElementById('betPlus'); if(betPlusEl) betPlusEl.addEventListener('click', ()=>{ betPerSpin = Math.min(MAX_BET, +(betPerSpin + BET_STEP).toFixed(2)); updateUI(); });
      const betMinusEl = document.getElementById('betMinus'); if(betMinusEl) betMinusEl.addEventListener('click', ()=>{ betPerSpin = Math.max(MIN_BET, +(betPerSpin - BET_STEP).toFixed(2)); updateUI(); });
    });

    if(leftInfo) leftInfo.innerHTML = 'Reels: 5×3 payline mode (10 paylines, min 3 on a payline).';
    // initial seed: prefer local crypto (no UI controls)
    if(window._seedFromCrypto) window._seedFromCrypto();
    // initialize reels
    if(typeof initReelStrips==='function') initReelStrips();
    // no beacon saved (local-only mode)
  </script>
  <!-- tweetnacl removed: no external beacon verification -->
</body>
</html>
